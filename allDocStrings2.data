-----------File: experiment/smsResults.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: experiment.smsResults
   :synopsis: Centralized facility to access the SMS results.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>
.. moduleauthor:: Ursula Laa <Ursula.Laa@assoc.oeaw.ac.at>
.. moduleauthor:: Doris Proschofsky <Doris.Proschofsky@assoc.oeaw.ac.at>
.. moduleauthor:: Wolfgang Magerl <wolfgang.magerl@gmail.com>


---Code snippet: def getAllResults(run=None):

---Doc string: 
    Get all analyses and topologies that have results.

    
---Code snippet: def getTopologies(analysis, run=None):

---Doc string: 
    Get all topologies of an analysis with constraints.

    
---Code snippet: def getConstraints(analysis, topology="all", run=None):

---Doc string: 
    Get constraints of an analysis.

    :returns: dictionary of constraints, if topology == "all"; single
              constraint for the passed topology, if only one topology is passed; 
              None if non-existent;

    
---Code snippet: def getSqrts(analysis, run=None):

---Doc string:  get the center-of-mass energy of the analysis.
    
---Code snippet: def getConditions(analysis, topology="all", fuzzy=True, run=None):

---Doc string: 
    Get conditions of an analysis.

    :returns: dictionary of conditions, if topology == "all"; single condition
              for the passed topology, if only one topology is passed; None if
              non-existent.

    
---Code snippet: def getaxes(analysis, topology=None, run=None):

---Doc string: Get information about the histogram axes for an analysis.

    For each topology list of dictionary, each dictionary corresponds to one
    histogram. The key axes gives string (mx-my), the key mz gives information
    on other masses, if you supply a topology, returns list for this topology
    only.

    
---Code snippet: def setBase(base):

---Doc string: 
    Set the base directory of the database.
    
    
---Code snippet: def getBase():

---Doc string: 
    Return the base directory of the database.
    
    
---Code snippet: def getURL(analysis, run=None):

---Doc string: 
    Get the URL of an analysis.
    
    
---Code snippet: def hasURL(analysis, run=None):

---Doc string: 
    Check if URL of an analysis exists.
---Code snippet: def getPAS(analysis, run=None):

---Doc string: 
    Get the PAS of an analysis.
    
    
---Code snippet: def getJournal(analysis, run=None):

---Doc string: 
    Get the journal of an analysis.
    
    
---Code snippet: def getLumi(analysis, run=None):

---Doc string: 
    Get the integrated luminosity for an analysis.
    
    
---Code snippet: def isPrivate(analysis, run=None):

---Doc string: 
    Check if analysis is flagged as private.
    
---Code snippet: def getExperiment(analysis, run=None):

---Doc string: 
    Check if run is ATLAS8TeV, else return CMS.
    
    
---Code snippet: def getComment(analysis, run=None):

---Doc string: 
    Get the comment of an analysis.
    
    
---Code snippet: def considerRuns(runs):

---Doc string: 
    Define the run labels to be considered.
    
    
---Code snippet: def _exists(analysis, topology, run=None):

---Doc string: 
    Check if the dictionary 'limit_topo' in <run>/<analysis>/sms.py exists.

    For topologies with intermediate masses, check if all dictionaries listed
    in the axes-information exist. If topology == None, check if
    <run>/<analysis>/sms.py exists.

    
---Code snippet: def getUpperLimit(analysis, topology, mx=None, my=None, run=None,
                  interpolate=False, expected=False):

---Doc string: 
    Get the upper limit for run/analysis/topology.

    :returns: None, if it does not exist; entire dictionary, if mx and my are
              None; upper limit at mx/my, if mx and my are floats;

    
---Code snippet: def getUpperLimitFromDictionary(analysis, topology, mx=None, my=None,
                                run=None, png=None, interpolate=False,
                                expected=False):

---Doc string: 
    Get an upper limit from the python dictionary.

    
---Code snippet: def getInterpolatedUpperLimitDelaunay(dictionary, inmx, inmy):

---Doc string: 
    Get interpolated upper limit from dictionary at point (inmx, inmy).

    :param dictionary: dictionary (sms.py), contains upper limits of one
                       analysis and one topology
    :param inmx: mass point on x-axis
    :param inmy: mass point on y-axis
    :returns: interpolated upper limit at point (inmx, inmy)

    
---Code snippet: def inConvexHull(dictionary, mx, my):

---Doc string: 
    Check if (mx,my) point is in the data dictionary.

    
---Code snippet: def getClosestValue(dictionary, mx, my):

---Doc string: 
    Get the upper limit of the point in dictionary that is closest to mx and
    my, assuming that dictionary is a dictionary of mx, my, ul.

    
-----------File: smodels/tools/__init__.py
---Code snippet: NOT FOUND
---Doc string: 
This package contains all code that cannot be classified as being part of
*experiment* or *theory*.


-----------File: theory/element.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: theory.element
   :synopsis: Module holding the Element class and its methods.
    
.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>
    

---Code snippet: class Element(Printer):

---Doc string: 
    An instance of this class represents an element.
    
    This class possesses a pair of branches and the element weight
    (cross-section * BR).
    
    
---Code snippet:     def __init__(self, info=None):
        self.branches = [Branch(), Branch()]
        self.weight = crossSection.XSectionList()
        self.motherElements = []

---Doc string:  Elements that arise from compression have mother elements.
            Mother elements are pairs of ( whence, element ),
            'whence' describing what the element is from 
            (mass compression, invisible compression, etc),
            while 'element' is the actual object.
            If element is not due to compression, 
            then list remains empty.
        
---Code snippet:     def combineMotherElements ( self, el2 ):

---Doc string:  combine mother elements from self and el2 into self 
---Code snippet:     def __str__(self):

---Doc string: 
        Create the canonical name of the element, e.g. [[jet],[jet]].
        
        
---Code snippet:     def isEqual(self, other, order=False, useDict=True):

---Doc string: 
        Compare two Elements for equality.
        
        If order == False, test both branch orderings (for an element doublet
        only). If useDict == True, allow for nclusive particle labels.
        
        :returns: True, if all masses and particles are equal; False, else;        
        
        
---Code snippet:     def particlesMatch(self, other, order=False, useDict=True):

---Doc string: 
        Compare two Elements for matching particles.
        
        If order == False, test both branch orderings (for an element doublet
        only). If useDict == True, allow for inclusive particle abels.
        
        :returns: True, if particles match; False, else;
        
        
---Code snippet:     def copy(self):

---Doc string: 
        Create a copy of self.
        
        Faster than deepcopy.
        
        
---Code snippet:     def setMasses(self, mass, sameOrder=True, opposOrder=False):

---Doc string: 
        Set the element masses to the input mass array.
        
        If sameOrder == True, set the masses to the same branch ordering. If
        opposOrder == True, set the masses to the opposite branch ordering. If
        both sameOrder == True and opposOrder == True, set the masses to the
        smaller of the two orderings.
        
        
---Code snippet:     def switchBranches(self):

---Doc string: 
        Switch branches, if the element contains a pair of them.
                
        
---Code snippet:     def getParticles(self):

---Doc string: 
        Get the array of particles in the element.   
             
        
---Code snippet:     def getMasses(self):

---Doc string: 
        Get the array of masses in the element.   
             
        
---Code snippet:     def getDaughters(self):

---Doc string: 
        Get a pair of daughter IDs.
        
        Can be None, if the element does not have a definite daughter.      
           
        
---Code snippet:     def getMothers(self):

---Doc string: 
        Get a pair of mother IDs.
        
        Can be None, if the element does not have a mother daughter.
        
        
---Code snippet:     def getEinfo(self):

---Doc string: 
        Get global topology info from particle string.
        
        
---Code snippet:     def _getLength(self):

---Doc string: 
        Get the maximum of the two branch lengths.
        
        
---Code snippet:     def isInList(self, listOfElements, igmass=False, useDict=True):

---Doc string: 
        Check if the element is present in the element list.
        
        If igmass == False also check if the analysis has the element mass
        array.
        
        
---Code snippet:     def checkConsistency(self):

---Doc string: 
        Check if the particles defined in the element exist and are consistent
        with the element info.
        
        
---Code snippet:     def compressElement(self, doCompress, doInvisible, minmassgap):

---Doc string: 
        Keep compressing they original element and the derived ones till they
        can be compressed no more.
        
        :returns: list with the compressed elements
        
        
---Code snippet:     def massCompress(self, mingap):

---Doc string: 
        Perform mass compression.
        
        :returns: compressed copy of the element, if two masses in this
                  topology are degenerate; None, if compression is not possible;
        
        
---Code snippet:     def hasTopInList(self, elementList):

---Doc string: 
        Check if the element topology matches any of the topologies in the
        element list.
        
        
---Code snippet:     def invisibleCompress(self):

---Doc string: 
        Compress cascade decays ending with neutrinos and daughter.
        
        If no compression is possible, return None.
        
        
---Code snippet:     def formatData(self):

---Doc string: 
        Select data preparation method through dynamic binding.
        
---Code snippet: def _smallerMass(mass1, mass2):

---Doc string: 
    Select the smaller of two mass arrays.
    
    Use an ordering criterion (machine-independent) for selection.
    
    
-----------File: smodels/theory/clusterTools.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: theory.clusterTools
   :synopsis: Module holding the ElementCluster class and cluster methods used to combine similar elements according
   to the analysis.
        
.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>
        

---Code snippet: class ElementCluster(object):

---Doc string: 
    An instance of this class represents a cluster.
    
    This class is used to store the relevant information about a cluster of
    elements and to manipulate this information.
    
    
---Code snippet:     def getTotalXSec(self):

---Doc string: 
        Return the sum over the cross-sections of all elements belonging to
        the cluster.
        
        
---Code snippet:     def getAvgMass(self):

---Doc string: 
        Return the average mass of all elements belonging to the cluster.
        
        :returns: average mass
         
        
---Code snippet: class IndexCluster(object):

---Doc string: 
    An instance of this class represents a cluster storing element indices.
    
    This auxiliary class is used to store element indices and positions in
    upper limit space. It is used by the clustering algorithm.
    
    
---Code snippet:     def add(self, iels):

---Doc string: 
        Add an index or a list of indices to the list of indices and update
        the avgPosition value.
        
        
---Code snippet:     def remove(self, iels):

---Doc string: 
        Remove an index or a list of indices to the list of indices and
        update the avgPosition value.
        
        
---Code snippet:     def _getAvgPosition(self):

---Doc string: 
        Return the average position in upper limit space for all indices
        belonging to the cluster.
        
        
---Code snippet:     def _getDistanceTo(self, obj):

---Doc string: 
        Return the maximum distance between any elements belonging to the
        cluster and the object obj.
        
        obj can be a position in upper limit space or an element index.
        
        
---Code snippet:     def _getMaxInternalDist(self):

---Doc string: 
        Return the maximum distance between any pair of elements belonging
        to the cluster as well as the cluster center and any element.
        
        
---Code snippet: def groupAll(elements):

---Doc string: 
    Create a single cluster containing all the elements.
    
    
---Code snippet: def clusterElements(elements, analysis, maxDist):

---Doc string:  Cluster the original elements according to their mass distance.
    
    :returns: list of clusters; If keepMassInfo == True, saves the original
              masses and their cluster value in massDict.
    
    
---Code snippet: def _doCluster(elements, analysis, maxDist):

---Doc string: 
    Cluster algorithm to cluster elements.
    
    :returns: a list of ElementCluster objects containing the elements
    belonging to the cluster
    
    
---Code snippet:     # First build the element:mass, element:position in UL space
    # and element:maxWeight (in fb) dictionaries
    #(Combine elements with identical masses)
    massMap = {}
    posMap = {}
    weightMap = {}
    for iel, el in enumerate(elements):
        if not el.getMasses() in massMap.values():
            massMap[iel] = el.getMasses()
            posMap[iel] = massPosition(massMap[iel], analysis)
            weightMap[iel] = rmvunit(el.weight.getMaxXsec(),'fb')
        else:
            j = massMap.keys()[massMap.values().index(el.getMasses())] 
            weightMap[j] += rmvunit(el.weight.getMaxXsec(),'fb')
    # Start with maximal clusters
    clusterList = []
    for iel in posMap:
        indices = [iel]
        for jel in posMap:            
            if distance(posMap[iel], posMap[jel]) <= maxDist:
                indices.append(jel)        
        indexCluster = IndexCluster(massMap, posMap, weightMap, set(indices), analysis)
        clusterList.append(indexCluster)

---Doc string: Split the maximal clusters until all elements inside each cluster are
    less than maxDist apart from each other and the cluster average position
    is less than maxDist apart from all elements
---Code snippet:     finalClusters = []
    newClusters = True
    while newClusters:
        newClusters = []
        for indexCluster in clusterList:
            # cluster is good
            if indexCluster._getMaxInternalDist() < maxDist:
                if not indexCluster in finalClusters:
                    finalClusters.append(indexCluster)
                continue
            # Distance to cluster center (average)
            distAvg = indexCluster._getDistanceTo(indexCluster.avgPosition)

---Doc string: Loop over cluster elements and if element distance or cluster
            average distance falls outside the cluster, remove element
---Code snippet: def _getGoodElements(elements, analysis, maxDist):

---Doc string: 
    Get the list of good masses appearing elements according to the analysis
    distance.
    
    :returns: list of elements with good masses with their masses replaced by
    the branch average. A mass is good if the mass distance between the
    branches is less than maxDist and if the element mass (or mass avg) falls
    inside the upper limit plane.
    
    
-----------File: smodels/theory/crossSection.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: theory.crossSection
   :synopsis: Encapsulates the result of the computation of the reference
              cross section.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>
.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>


---Code snippet: class XSectionInfo(object):

---Doc string: 
    An instance of this class represents information regarding a cross-section.
    
    This class is used to store information of a cross-section (center of
    mass, order and label).
    
    
---Code snippet:     def copy(self):

---Doc string: 
        Generate an independent copy of self.
        
        Faster than deepcopy.
        
        
---Code snippet: class XSection(object):

---Doc string: 
    An instance of this class represents a cross-section.
    
    This class is used to store the information of a single cross-section
    (value, paritcle ids, center of mass, order and label).
    
    order = 0 (LO), 1 (NLO) or 2 (NLL).
    
    
---Code snippet:     def __str__(self):

---Doc string: 
        Generate cross-section information in string format.
        
        
---Code snippet:     def copy(self):

---Doc string: 
        Generates an independent copy of self.
        
        Faster than deepcopy.
        
        
---Code snippet:     def _zeroXSec(self):

---Doc string: 
        Replace the cross-section value by zero.
        
        
---Code snippet: class XSectionList(object):

---Doc string: 
    An instance of this class represents a list of cross-sections.
    
    This class is used to store a list of cross-sections.
    
    
---Code snippet:     def __init__(self, infoList=None):

---Doc string: 
        If infoList is defined, create entries with zero cross-sections
        according to infoList. infoList must be a list of XSectionInfo objects.
        
        
---Code snippet:     def copy(self):

---Doc string: 
        Generates an independent copy of itself. Faster than deepcopy.
        
        
---Code snippet:     def add(self, newxsec):

---Doc string: 
        Append a XSection object to the list.
        
        
---Code snippet:     def _addValue(self, newxsec):

---Doc string: 
        Add a XSection object to the list.
        
        If the XSection object already exists, add to its values, otherwise
        append the object.
        
        
---Code snippet:     def getXsecsFor(self, item):

---Doc string: 
        Return a list of XSection objects for item (label, pid, sqrts).
        
        
---Code snippet:     def _zeroXSecs(self):

---Doc string: 
        Replace the cross-section values in the list by zero.
        
        
---Code snippet:     def delete(self, xSec):

---Doc string: 
        Delete the cross-section entry from the list.
        
        
---Code snippet:     def getInfo(self):

---Doc string: 
        Get basic info about the cross-sections appearing in the list (order,
        value and label).
        
        :returns: list of XSectionInfo objects
                
        
---Code snippet:     def _getLabels(self):

---Doc string: 
        Get all labels appearing in the list.
        
        
---Code snippet:     def getPIDpairs(self):

---Doc string: 
        Get all particle ID pairs appearing in the list.
        
        
---Code snippet:     def getPIDs(self):

---Doc string: 
        Get all particle IDs appearing in the list.
        
        
---Code snippet:     def getMaxXsec(self):

---Doc string: 
        Get the maximum cross-section value appearing in the list.
        
        
---Code snippet:     def getMinXsec(self):

---Doc string: 
        Get minimum cross-section value appearing in the list.
        
        
---Code snippet:     def getDictionary(self, groupBy="pids"):

---Doc string: 
        Convert the list of XSection objects to a nested dictionary.
        
        First level keys are the particles IDs (if groupBy == pids) or labels
        (if groupBy == labels) and values are the cross-section labels or
        particle IDs and the cross-section value. If groupBy == pids and a
        single pid is present, return a simple dictionary with the
        cross-sections for the pid.
        
        
---Code snippet:     def combineWith(self, newXsecs):

---Doc string: 
        Add a new list of cross-sections.
        
        If the new cross-sections already appear (have same order and sqrts),
        add its value to the original value, otherwise append it to the list.
        The particle IDs are ignored when adding cross-sections. Hence, they
        are set to (None, None) if any cross-sections are combined.
        
        
---Code snippet:     def removeLowerOrder(self):

---Doc string: 
        Keep only the highest order cross-section for each process in the list.
        
        Remove order information and set default labels.
        
        
---Code snippet: def getXsecFromSLHAFile(slhafile, useXSecs=None):

---Doc string: 
    Obtain cross-sections from input SLHA file. 
    
    :param slhafile: SLHA input file with cross-sections
    :param useXSecs: if defined enables the user to select cross-sections to
                     use. Must be a XSecInfoList object
    :returns: a XSectionList object    
     
    
---Code snippet: def getXsecFromLHEFile(lhefile, addEvents=True):

---Doc string: 
    Obtain cross-sections from input LHE file.
    
    :param lhefile: LHE input file with unweighted MC events
    :param addEvents: if True, add cross-sections with the same mothers,
                      otherwise return the event weight for each pair of mothers
    :returns: a XSectionList object
    
    
-----------File: theory/__init__.py
---Code snippet: NOT FOUND
---Doc string: 
This Package is intended to contain everything related to theory:

   * cross section calculation code
   * sms decomposition code (LHE-based, SLHA-based)
   * some more tools, e.g. for reading/writing slha files, or particle names
   

-----------File: smodels/validation/database/2012/SUS12002/sms.py
No doc strings
-----------File: tools/externalPythonTools.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: externalPythonTools
   :synopsis: this module is to check the installation of python tools, 
              i.e. unum, scipy, numpy.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: class ExternalPythonTool(object):

---Doc string: 
    An instance of this class represents the installation of unum.
    As it is python-only, we need this only for installation,
    not for running (contrary to nllfast or pythia).
    
    
---Code snippet:     def checkInstallation(self):

---Doc string: 
        The check is basically done in the constructor
        
-----------File: smodels/tools/externalPythia8.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: externalPythia8
   :synopsis: Wrapper for pythia8.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: class ExternalPythia8(ExternalTool):

---Doc string: 
    An instance of this class represents the installation of pythia8.
    
    
---Code snippet:     def compile(self):

---Doc string: 
        Compile pythia_lhe.
        
        
---Code snippet:     def checkInstallation(self):

---Doc string: 
        Check if installation of tool is correct by looking for executable and
        running it.
        
        
-----------File: smodels/experiment/limitGetter.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: experiment.limitGetter
   :synopsis: Access the proper experimental limits to given analysis objects.

.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>
.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>
.. moduleauthor:: Ursula Laa <Ursula.Laa@assoc.oeaw.ac.at>


---Code snippet: def limit(analysis, addTheoryPredictions=[]):

---Doc string: 
    Get limit from an analysis object.

    :param addTheoryPredictions: list of theory predictions to add, e.g.,
                                 [ '7 TeV (NLL)', '7 TeV (LO)' ]
    :type addTheoryPredictions: [String]
    
---Code snippet: def getPlotLimit(inmass, analysis):

---Doc string: 
    Get upper limit on sigma*BR for a specific array of masses from plot.
    
    :param inmass: Array of masses in SModelS graph.
    :param analysis: experiment.analysis.ULanalysis.
    
    
-----------File: smodels/tools/rcFile.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: rcFile
   :synopsis: When imported, ~/.smodelsrc is parsed.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: def yesno(B):

---Doc string: 
    TODO: write docstring
    
    
---Code snippet: def parseRCFile():

---Doc string: 
    TODO: write docstring
    
    
---Code snippet:     import setPath
    rcfile = os.path.expanduser("~") + "/.smodelsrc"
    exists = os.path.exists(rcfile)
    if exists:
        execfile(rcfile)
        return True
    return False
parseRCFile()
if __name__ == "__main__":

---Doc string: 
    Check if there is a smodelsrc file.
    
    
-----------File: smodels/tools/toolBox.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: toolBox
   :synopsis: Contains a singleton-like class that keeps track of all external tools

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: class ToolBox(object):

---Doc string: 
    A singleton-like class that keeps track of all external tools.
    
    
---Code snippet:     def initSingleton(self):

---Doc string: 
        Intialize singleton instance (done only once for the entire class).
        
        
---Code snippet:     def add(self, instance):

---Doc string: 
        Adds a tool by passing an instance to this method.
        
        
---Code snippet:     def listOfTools(self):

---Doc string: 
        Returns a simple list with the tool names.
        
        
---Code snippet:     def get(self, tool, verbose=True):

---Doc string: 
        Gets instance of tool from the toolbox.
        
        
-----------File: smodels/tests/runCompleteTestSuite.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: runCompleteTestSuite
   :synopsis: Runs all test suites.
    
.. moduleauthor:: Wolfgang Magerl <wolfgang.magerl@gmail.com>
.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com> 
    

---Code snippet: def testScript ( filename ):

---Doc string:  is filename of the form 'test*py'? 
-----------File: theory/smsEvent.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: smsEvent
   :synopsis: Provides a class that encapsulates an LHE or SLHA event.
        
.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>
.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>
        

---Code snippet: class SmsEvent(object):

---Doc string: 
    Event class featuring a list of particles and some convenience functions.
    
    
---Code snippet:     def metaInfo(self, key):

---Doc string: 
        Return the meta information of 'key', None if info does not exist.
        
        
---Code snippet:     def add(self, particle):

---Doc string: 
        Add particle to the event.
        
        
---Code snippet:     def getMom(self):

---Doc string: 
        Return the pdgs of the mothers, None if a problem occurs.
        
        
---Code snippet: class Particle(object):

---Doc string: 
    An instance of this class represents a particle.
    
    
-----------File: tools/asciiGraph.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: asciiGraph
   :synopsis: Contains a simple routine to draw ASCII-art Feynman-like graphs.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: def _printParticle(label):

---Doc string: 
    Rename particles for the asciidraw routine.
    
    
---Code snippet: def _drawBranch(branch, upwards, labels, htmlFormat, border, l):

---Doc string: 
    Draw a single branch.
    
    
---Code snippet: def asciidraw(element, labels=True, html=False, border=False):

---Doc string: 
    Draw a simple ASCII graph on the screen.
    
    
-----------File: tests/testSlhaDecomposition.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: testSlhaDecomposition
   :synopsis: Checks slha decomposition, alongside with compression
    
.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>
    

---Code snippet:     def test(self):
        self.logger.info ( "test decomposition, no compression" )

---Doc string:  test the decomposition with no compression 
-----------File: smodels/validation/plots_closure/plotExcludedT1tt.py
No doc strings
-----------File: smodels/tools/externalPythonTools.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: externalPythonTools
   :synopsis: this module is to check the installation of python tools, 
              i.e. unum, scipy, numpy.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: class ExternalPythonTool(object):

---Doc string: 
    An instance of this class represents the installation of unum.
    As it is python-only, we need this only for installation,
    not for running (contrary to nllfast or pythia).
    
    
---Code snippet:     def checkInstallation(self):

---Doc string: 
        The check is basically done in the constructor
        
-----------File: smodels/tools/asciiGraph.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: asciiGraph
   :synopsis: Contains a simple routine to draw ASCII-art Feynman-like graphs.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: def _printParticle(label):

---Doc string: 
    Rename particles for the asciidraw routine.
    
    
---Code snippet: def _drawBranch(branch, upwards, labels, htmlFormat, border, l):

---Doc string: 
    Draw a single branch.
    
    
---Code snippet: def asciidraw(element, labels=True, html=False, border=False):

---Doc string: 
    Draw a simple ASCII graph on the screen.
    
    
-----------File: smodels/validation/database/2012/SUS12003/sms.py
No doc strings
-----------File: validation/database/2012/SUS12005/sms.py
No doc strings
-----------File: smodels/tools/uniqueLogFilter.py
---Code snippet: import logging

---Doc string: 
.. module:: uniqueLogFilter
   :synopsis: Contains a stolen code snippet for a logging filter to
       have identical log messages appear only once.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: class UniqueFilter(logging.Filter):

---Doc string: Messages are allowed through just once.
    The 'message' includes substitutions, but is not formatted by the 
    handler. If it were, then practically all messages would be unique!
    stolen from: http://code.activestate.com/recipes/412552-using-the-logging-module/
    
---Code snippet:     def reset(self):

---Doc string: Act as if nothing has happened.
---Code snippet:     def filter(self, rec):

---Doc string: logging.Filter.filter performs an extra filter on the name.
---Code snippet:     def __is_first_time(self, rec):

---Doc string: Emit a message only once.
-----------File: theory/branch.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: theory.branch
   :synopsis: Module holding the branch class and methods.
        
.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>
        

---Code snippet: class Branch(object):

---Doc string: 
    An instance of this class represents a branch.
    
    A branch-element can be constructed from a string (e.g., ('[b,b],[W]').
    
    
---Code snippet:     def __str__(self):

---Doc string: 
        Create the canonical SModels description of the Branch.
        
        
---Code snippet:     def isEqual(self, other, useDict=True):

---Doc string:  Compare the branch with other. If particles are similar
        and masses are equal, return True. Otherwise, return False.        
        
---Code snippet:     def copy(self):

---Doc string: 
        Generate an independent copy of self.
        
        Faster than deepcopy.
        
        
---Code snippet:     def getLength(self):

---Doc string: 
        Returns the branch length (= number of R-odd masses).
        
        
---Code snippet:     def _addDecay(self, br, massDictionary):

---Doc string: 
        Generate a new branch adding a 1-step cascade decay.
        
        This is described by the br object, with particle masses given by
        massDictionary.
        
        
---Code snippet:     def decayDaughter(self, brDictionary, massDictionary):

---Doc string: 
        Generate a list of all new branches generated by the 1-step cascade
        decay of the current branch daughter.
        
        
---Code snippet: def decayBranches(branchList, brDictionary, massDictionary,
                  sigcut=addunit(0., 'fb')):

---Doc string: 
    Decay all branches from branchList until all R-odd particles have decayed.
    
    :param branchList: list of Branch() objects containing the initial mothers
    :param brDictionary: branching ratio dictionary for all particles appearing
                         in the decays
    :param massDictionary: mass dictionary for all particles appearing in the
                           decays
    :param sigcut: minimum sigma*BR to be generated, by default sigcut = 0.
                   (all branches are kept)
    
    
-----------File: smodels/tools/externalNllFast.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: externalNllFast
   :synopsis: Wrapper for all nllfast versions.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: class ExternalNllFast(ExternalTool):

---Doc string: 
    An instance of this class represents the installation of nllfast.
    
    
---Code snippet:     def __init__(self, sqrts, nllfast_version, test_params, test_condition):

---Doc string: 
        :param sqrts: sqrt of s, in TeV, as an integer,
        :param nllfast_version: version of the nllfast tool
        :param test_params: what are the test params we need to run things with?
        :param test_condition: the line that should be the last output line when
        running executable
        :src_path: the path of the source code, for compilation
        
        
---Code snippet:     def compile(self):

---Doc string: 
        Try to compile nllfast.
        
        
---Code snippet:     def fetch(self):

---Doc string: 
        Fetch and unpack tarball.
        
        
---Code snippet:     def unlink(self, inputFile):

---Doc string: 
        Remove inputFile.out 
        
        
---Code snippet:     def run_(self, params):

---Doc string: 
        Execute nllfast7.
        
        :params params: parameters used (e.g. gg cteq5 .... )
        :returns: stdout and stderr, or error message
        
        
---Code snippet:     def run(self, process, pdf, squarkmass, gluinomass):

---Doc string: 
        Execute nllfast.
        
        :params process: which process: st, sb, gg, gdcpl, sdcpl, ss, sg, tot
        :params pdf: cteq=cteq6, mstw2008 
        :params squarkmass: squarkmass, None if squark decoupled
        :params gluinomass: gluinomass, None if gluino decoupled
        :returns: stdout and stderr, or error message
        
        
---Code snippet:     def checkInstallation(self):

---Doc string: 
        Checks if installation of tool is valid by looking for executable and
        executing it.
        
        
---Code snippet: class ExternalNllFast7(ExternalNllFast):

---Doc string: 
    An instance of this class represents the installation of nllfast 7.
    
    
---Code snippet: class ExternalNllFast8(ExternalNllFast):

---Doc string: 
    An instance of this class represents the installation of nllfast 8.
    
    
---Code snippet: class ExternalNllFast13(ExternalNllFast):

---Doc string: 
    An instance of this class represents the installation of nllfast 13.
    
    
---Code snippet: class ExternalNllFast14(ExternalNllFast):

---Doc string: 
    An instance of this class represents the installation of nllfast 14.
    
    
---Code snippet: class ExternalNllFast33(ExternalNllFast):

---Doc string: 
    An instance of this class represents the installation of nllfast 33.
    
    
-----------File: validation/plots_closure/addMetadata.py
No doc strings
-----------File: tests/setPath.py
---Code snippet: #!/usr/bin/python

---Doc string:                                                                                    
.. module:: setPath
   :synopsis: Sets the path such that e.g. "from tools import rootTools" works
   correctly. Called as a script, the path is printed.
                                                                                      
.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>             
                                                                                      

---Code snippet: def configure():

---Doc string: 
    Get the path name of this file, remove set_path.py, remove the last
    subdir.
    
    The remaining string should be the base path name.
    
    
---Code snippet:     base = os.path.dirname(os.path.realpath(inspect.getabsfile(configure)))
    pos = base.rfind("/")
    base = base[:pos + 1]
    sys.path.append(base)
    # sys.path.append(base[:-9])
    return base
configure()
if __name__ == "__main__":

---Doc string: 
    Called as a script, print out the path.
    
    
-----------File: validation/plots_closure/plotExcludedT2tt.py
No doc strings
-----------File: smodels/tests/testIntegration.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: testIntegration
   :synopsis: Integration test, tests a simple but complete use case.
              Uses the database in smodels/validation/database.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


-----------File: theory/crossSection.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: theory.crossSection
   :synopsis: Encapsulates the result of the computation of the reference
              cross section.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>
.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>


---Code snippet: class XSectionInfo(object):

---Doc string: 
    An instance of this class represents information regarding a cross-section.
    
    This class is used to store information of a cross-section (center of
    mass, order and label).
    
    
---Code snippet:     def copy(self):

---Doc string: 
        Generate an independent copy of self.
        
        Faster than deepcopy.
        
        
---Code snippet: class XSection(object):

---Doc string: 
    An instance of this class represents a cross-section.
    
    This class is used to store the information of a single cross-section
    (value, paritcle ids, center of mass, order and label).
    
    order = 0 (LO), 1 (NLO) or 2 (NLL).
    
    
---Code snippet:     def __str__(self):

---Doc string: 
        Generate cross-section information in string format.
        
        
---Code snippet:     def copy(self):

---Doc string: 
        Generates an independent copy of self.
        
        Faster than deepcopy.
        
        
---Code snippet:     def _zeroXSec(self):

---Doc string: 
        Replace the cross-section value by zero.
        
        
---Code snippet: class XSectionList(object):

---Doc string: 
    An instance of this class represents a list of cross-sections.
    
    This class is used to store a list of cross-sections.
    
    
---Code snippet:     def __init__(self, infoList=None):

---Doc string: 
        If infoList is defined, create entries with zero cross-sections
        according to infoList. infoList must be a list of XSectionInfo objects.
        
        
---Code snippet:     def copy(self):

---Doc string: 
        Generates an independent copy of itself. Faster than deepcopy.
        
        
---Code snippet:     def add(self, newxsec):

---Doc string: 
        Append a XSection object to the list.
        
        
---Code snippet:     def _addValue(self, newxsec):

---Doc string: 
        Add a XSection object to the list.
        
        If the XSection object already exists, add to its values, otherwise
        append the object.
        
        
---Code snippet:     def getXsecsFor(self, item):

---Doc string: 
        Return a list of XSection objects for item (label, pid, sqrts).
        
        
---Code snippet:     def _zeroXSecs(self):

---Doc string: 
        Replace the cross-section values in the list by zero.
        
        
---Code snippet:     def delete(self, xSec):

---Doc string: 
        Delete the cross-section entry from the list.
        
        
---Code snippet:     def getInfo(self):

---Doc string: 
        Get basic info about the cross-sections appearing in the list (order,
        value and label).
        
        :returns: list of XSectionInfo objects
                
        
---Code snippet:     def _getLabels(self):

---Doc string: 
        Get all labels appearing in the list.
        
        
---Code snippet:     def getPIDpairs(self):

---Doc string: 
        Get all particle ID pairs appearing in the list.
        
        
---Code snippet:     def getPIDs(self):

---Doc string: 
        Get all particle IDs appearing in the list.
        
        
---Code snippet:     def getMaxXsec(self):

---Doc string: 
        Get the maximum cross-section value appearing in the list.
        
        
---Code snippet:     def getMinXsec(self):

---Doc string: 
        Get minimum cross-section value appearing in the list.
        
        
---Code snippet:     def getDictionary(self, groupBy="pids"):

---Doc string: 
        Convert the list of XSection objects to a nested dictionary.
        
        First level keys are the particles IDs (if groupBy == pids) or labels
        (if groupBy == labels) and values are the cross-section labels or
        particle IDs and the cross-section value. If groupBy == pids and a
        single pid is present, return a simple dictionary with the
        cross-sections for the pid.
        
        
---Code snippet:     def combineWith(self, newXsecs):

---Doc string: 
        Add a new list of cross-sections.
        
        If the new cross-sections already appear (have same order and sqrts),
        add its value to the original value, otherwise append it to the list.
        The particle IDs are ignored when adding cross-sections. Hence, they
        are set to (None, None) if any cross-sections are combined.
        
        
---Code snippet:     def removeLowerOrder(self):

---Doc string: 
        Keep only the highest order cross-section for each process in the list.
        
        Remove order information and set default labels.
        
        
---Code snippet: def getXsecFromSLHAFile(slhafile, useXSecs=None):

---Doc string: 
    Obtain cross-sections from input SLHA file. 
    
    :param slhafile: SLHA input file with cross-sections
    :param useXSecs: if defined enables the user to select cross-sections to
                     use. Must be a XSecInfoList object
    :returns: a XSectionList object    
     
    
---Code snippet: def getXsecFromLHEFile(lhefile, addEvents=True):

---Doc string: 
    Obtain cross-sections from input LHE file.
    
    :param lhefile: LHE input file with unweighted MC events
    :param addEvents: if True, add cross-sections with the same mothers,
                      otherwise return the event weight for each pair of mothers
    :returns: a XSectionList object
    
    
-----------File: tools/callGraph.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: callGraph
   :synopsis: Call pycallgraph to create call graphs of simpleExample for
              different input files.
              Usage: has to be invoked in the SModelS root directory:
              >>> python -m tools.callGraph
              >>> python -m tools.callGraph --max-depth 3

.. moduleauthor:: Wolfgang Magerl <wolfgang.magerl@gmail.com>


---Code snippet: def main():

---Doc string: 
    Executes pycallgraph to create call graphs of simpleExample.
    
    
-----------File: smodels/simpleExample.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: simpleExample
   :synopsis: Basic use case for the SModelS framework.

.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>


---Code snippet: def main():

---Doc string: 
    Main program. Displays basic use case.

    
-----------File: tests/testSlhaChecks.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: testSlhaChecks
   :synopsis: Tests the slha checker

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>
.. moduleauthor:: Ursula Laa <Ursula.Laa@assoc.oeaw.ac.at>


-----------File: smodels/theory/auxiliaryFunctions.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: theory.auxiliaryFunctions
   :synopsis: A collection of functions used to evaluate fuzzy the conditions.

.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>


---Code snippet: def _memoize(func):

---Doc string: 
    Cache the results of massPosition.
    
    Serves as a wrapper to cache the results of massPosition, since this is a
    computationally expensive function.
    
    
---Code snippet: def massPosition(mass, analysis):

---Doc string:  Give mass position in upper limit space.    
    Use the analysis experimental limit data.    
    
---Code snippet: def distance(xmass1, xmass2):

---Doc string: 
    Define distance between two mass positions.
    
    
---Code snippet: def massAvg(massList, method='weighted', weights=None):

---Doc string: 
    Compute the average mass of massList according to method.

    If method=weighted but weights were not properly defined,
    switch method to harmonic.    
    If massList contains a zero mass, switch method to mean.
    
    :param method: possible values: harmonic, mean, weighted
    :param weights: weights of elements (only for weighted average)
    
    
---Code snippet: def cSim(*weights):

---Doc string: 
    Define the auxiliar similar function.
    
    Return the maximum relative difference between any element weights of the
    list, normalized to [0,1].
    
    :returns: XSectionList object with the values for each label.
    
    
---Code snippet: def cGtr(weightA, weightB):

---Doc string: 
    Define the auxiliary greater function.
    
    Return a number between 0 and 1 depending on how much it is violated
    (0 = A > B, 1 = A << B).
    
    :returns: XSectioList object with the values for each label.
    
    
---Code snippet: def _flattenList(inlist, dims=None):

---Doc string: 
    Flatten a multi-dimensional nested list.
    
    Output ordering: [first level objects, second level objects, ...].    
    
    If dims == [], include dimensions of nested list to it. This is useful when
    comparing lists).
    
    
-----------File: tests/testTimeout.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: testTimeout
   :synopsis: checks if the timeout of pythia6 works
    
.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>
    

-----------File: smodels/tools/slhaChecks.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
    .. module:: slhaChecks
       :synopsis: Check SLHA file for integrity.

        .. moduleauthor:: Ursula Laa <Ursula.Laa@assoc.oeaw.ac.at>
        .. moduleauthor:: Veronika Magerl <v.magerl@gmx.at>
        .. moduleauthor:: Suchita Kulkarni <suchita.kulkarni@gmail.com>


---Code snippet: class SlhaStatus(Printer):

---Doc string: 
    An instance of this class represents the status of an SLHA file.
    The output status is 0 if the file is not checked, 1 if the check is ok
    The final status is -1 in case of a physical problem, e.g. charged LSP,
    and -2 in case of formal problems, e.g. missing decay blocks, in the file
    The parameter maxFlightlength is specified in meters. 
    
---Code snippet:     def read(self):

---Doc string: 
        Get pyslha output object.
        
        
---Code snippet:     def evaluateStatus(self):

---Doc string: 
        Get status summary from all performed checks.

        :returns: a status flag and a message for explanation

        
---Code snippet:     def checkDecayBlock(self, findMissingDecays):

---Doc string: 
        Check if there is a decay table for each particle with pid > 50 given
        in the mass block.
        
        
---Code snippet:     def checkCtau(self, checkFlightlength):

---Doc string: 
        Check if c*tau of NLSP is larger than given maximum.
        Report error for long lived, charged NLSP.

        
---Code snippet:     def findEmptyDecay(self, findEmpty):

---Doc string: 
        Find all particles that are considered stable in SModelS.
        
        Stable particle means that no branching ratios are given in the
        decay table of the particle in the slha file.
        
        
---Code snippet:     def hasXsec(self, checkXsec):

---Doc string: 
        Check if XSECTION table is present in the slha file.
        
        
---Code snippet:     def testLSP(self, checkLSP):

---Doc string: 
        Check if lsp is charged.
        
        
---Code snippet:     def findLSP(self, returnmass=None):

---Doc string: 
        Find lightest particle with pid > 50.
        
        :returns: pid, mass of the lsp, if returnmass == True
        
        
---Code snippet:     def getLifetime(self, pid, ctau=False):

---Doc string: 
        Compute lifetime from decay-width for a particle with pid.
        
        
---Code snippet:     def sumBR(self, pid):

---Doc string: 
        Calculate the sum of all branching ratios for particle with pid.
        
        
---Code snippet:     def deltaMass(self, pid1, pid2):

---Doc string: 
        Calculate mass splitting between particles with pid1 and pid2.
        
        
---Code snippet:     def findNLSP(self, returnmass = None):

---Doc string: 
        Find second lightest particle with pid >= 50.
        
        :returns: pid ,mass of the NLSP, if returnmass == True
        
        
---Code snippet:     def getDecayWidths(self):

---Doc string: 
        Get all decay-widths as a dictionary {pid: width}.
        
        
---Code snippet:     def getDecayWidth(self, pid):

---Doc string: 
        Get the decay-width for particle with pid, if it exists.
        
        
---Code snippet:     def massDiffLSPandNLSP(self):

---Doc string: 
        Get the mass difference between the lsp and the nlsp.
        
        
---Code snippet:     def findDisplacedVertices(self, findDisplaced):

---Doc string: 
        find meta-stable particles that decay via leptons or higgs
        
---Code snippet:     def getXSEC(self, pid, sqrts=8000.):

---Doc string: 
        get crosssection for pair production, read last line
        
---Code snippet:     def degenerateChi(self):

---Doc string: 
        Check if chi01 is lsp and chipm1 is NLSP. If so, check mass splitting.
        This function is not used, the limit is arbitrary.

        
---Code snippet: class Qnumbers:

---Doc string: 
    An instance of this class represents quantum numbers.
    
    Get quantum numbers (spin*2, electrical charge*3, color dimension) from "model"_qNumbers.
    
    
-----------File: smodels/theory/printer.py
---Code snippet: NOT FOUND
---Doc string: 
    .. module:: printer
       :synopsis: Facility used in classes to derive from and be able to print
                  different data types in different forms.

        .. moduleauthor:: Wolfgang Magerl <wolfgang.magerl@gmail.com>
        .. moduleauthor:: Ursula Laa <Ursula.Laa@assoc.oeaw.ac.at>    
        .. moduleauthor:: Suchita Kulkanri <suchita.kulkarni@gmail.com>

---Code snippet: class Printer(object):

---Doc string: 
    Printer class.
    
    
---Code snippet:     def printout(self, target="stdout", filename=""):

---Doc string: 
        Print the content of the data structure to the target.

        :param target: The target to print to. Possible values: stdout, file.
                       Default: stdout.
        :param filename: Filename to which the output is written
        :returns: None
        
        
---Code snippet:     def formatData(self):

---Doc string: 
        Format data of the derived object.
        
        Has to be implemented in the derived object. The real implementation is
        selected through dynamic binding.
        
        :raises: NotImplementedError  
              
        
---Code snippet:     def formatTopologyListData(self):
        from smodels.tools.physicsUnits import rmvunit

---Doc string: 
        Format data of to print Global topologies object.
        
---Code snippet:     def formatElementData(self):

---Doc string: 
            Format data of to print an element object.
        
---Code snippet:     def formatTheoryPredictionData(self):

---Doc string: 
        Format data of a TheoryPrediction object.
        
        
---Code snippet:     def formatStatusData(self):

---Doc string: 
        Format data of the output status object.
        
---Code snippet:     def formatResultsData(self):

---Doc string: 
        Format data of the final output object.
        
---Code snippet:     def formatSLHAData(self):

---Doc string: 
        Format data of the slha checks output object.
        
---Code snippet:     def formatMissingData(self):

---Doc string: 
        Format data of missing topology list.
        
-----------File: smodels/experiment/smsInterpolation.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: experiment.smsInterpolation
   :synopsis: smsInterpolation is called by smsResults.getSmartUpperLimit. UpperLimit
       takes arbitrary input masses and checks if there is a corresponding upper
       limit for the given analysis and topology. The upper limit is returned in
       'pb'. If several histograms with different x-values are available, an
       interpolation is performed.

.. moduleauthor:: Ursula Laa <Ursula.Laa@assoc.oeaw.ac.at>


---Code snippet: def upperLimit(analysis, topology, masses, run=None):

---Doc string: 
    Return upper limit for analysis-topology for given masses. 
    
    :param masses: list of masses, with (mother, intermediate(s), LSP). For
           intermediate masses: if possible do interpolation over upper limits for
           different x-values. If interpolation is not possible: check if masses are
           comparable to the assumptions in the histogram.
    
    
---Code snippet: def _getHistName(topo, mz):

---Doc string: 
    Build histogram name for given topology and mz information.
    
    :param mz: given in the axes-information
    
    
---Code snippet: def _doGridData(analysis, topology, masses, dPar, run=None):

---Doc string: 
    Create np.array and uses scipy.griddata function for analysis-topology.
    
    
---Code snippet: def _getAxis(w, a):

---Doc string: 
    Find according index in the masses-list for w == x, y.
    
    Use the axes-information a == (mx - my).
    
    
---Code snippet: def _getxval(mx, my, mz, mass=False):

---Doc string: 
    Calculate x-value for one point.
    
    If mass == True is selected, return intermediate mass instead of x-value.
    
    :param mx: Mother-mass
    :param my: LSP-mass
    :param mz: information on the intermediate mass as given in the
    axes-information.
    
    
---Code snippet: def _compareMasses(masses, d):

---Doc string: 
    Check if input masses are comparable to masses in the histogram.
    
    Masses are comparable corresponding to the information given in
    axes-dictionary d.
    
    
---Code snippet: def _getIndex(ls, second=False):

---Doc string: 
    Find index of list element with maximum value.
    
    If the last element is the maximum, return -1. If second == True, find
    second largest list element.
    
    
-----------File: smodels/recipes/setPath.py
---Code snippet: #!/usr/bin/python

---Doc string:                                                                                    
.. module:: setPath
   :synopsis: Sets the path such that e.g. "from tools import rootTools" works
   correctly. Called as a script, the path is printed.
                                                                                      
.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>             
                                                                                      

---Code snippet: def configure():

---Doc string: 
    Get the path name of this file, remove set_path.py, remove the last
    subdir.
    
    The remaining string should be the base path name.
    
    
---Code snippet:     base = os.path.dirname(os.path.realpath(inspect.getabsfile(configure)))
    pos = base.rfind("/")
    base = base[:pos + 1]
    sys.path.append(base)
    # sys.path.append(base[:-9])
    return base
configure()
if __name__ == "__main__":

---Doc string: 
    Called as a script, print out the path.
    
    
-----------File: tools/smsPrettyPrinter.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: smsPrettyPrinter
   :synopsis: missing

.. moduleauthor:: missing <email@example.com>


---Code snippet: class SmsPrettyPrinter(PrettyPrinter):

---Doc string: 
    An instance of this class represents a printing facility."
    
    
---Code snippet:     def format(self, entity, context, maxlevels, level):

---Doc string: 
        TODO: write docstring
        
        
---Code snippet: def wrapOnspace(text, width):

---Doc string: 
    Preserves existing line breaks and most spaces in the text. Expects that
    existing line breaks are posix newlines (\\n).
    
    
---Code snippet: def wrapAlways(text, width):

---Doc string: 
    Wraps text on exactly width characters. It doesn't split the text in words.
    
    
---Code snippet: def wrap(text, width):

---Doc string: 
    Similar to wrapOnspace, but enforces the width constraint: words longer
    than width are split.
    
    
-----------File: smodels/theory/smsEvent.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: smsEvent
   :synopsis: Provides a class that encapsulates an LHE or SLHA event.
        
.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>
.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>
        

---Code snippet: class SmsEvent(object):

---Doc string: 
    Event class featuring a list of particles and some convenience functions.
    
    
---Code snippet:     def metaInfo(self, key):

---Doc string: 
        Return the meta information of 'key', None if info does not exist.
        
        
---Code snippet:     def add(self, particle):

---Doc string: 
        Add particle to the event.
        
        
---Code snippet:     def getMom(self):

---Doc string: 
        Return the pdgs of the mothers, None if a problem occurs.
        
        
---Code snippet: class Particle(object):

---Doc string: 
    An instance of this class represents a particle.
    
    
-----------File: validation/SMScheck.py
No doc strings
-----------File: smodels/tools/externalTool.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: externalTool
   :synopsis: Wrapper code for external tools: base class

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: class ExternalTool(object):

---Doc string: 
    An instance of this class represents the installation of an external tool.
    
    An external tool encapsulates a tool that is executed via
    commands.getoutput. It defines how the tool is tested for proper
    installation and how the tool is executed.
    
    
---Code snippet:     def installDirectory(self):

---Doc string: 
        TODO: write docstring
        
        
---Code snippet:     def pathOfExecutable(self):

---Doc string: 
        :returns: path of executable
        
        
---Code snippet:     def basePath(self):

---Doc string: 
        Get the base installation path.
        
        
---Code snippet:     def absPath(self, path):

---Doc string: 
        Get the absolute path of <path>, replacing <install> with the
        installation directory.
        
        
---Code snippet:     def ok(self,B):

---Doc string: 
        return 'ok', B is True. Else, return 'error'
        
        
-----------File: smodels/theory/slhaDecomposer.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: theory.slhaDecomposer
   :synopsis: Decomposition of SLHA events and creation of TopologyLists.
        
.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>
        

---Code snippet: def decompose(slhafile, sigcut=0.1, doCompress=False, doInvisible=False,
              minmassgap=-1, useXSecs=None):

---Doc string: 
    Perform SLHA-based decomposition.
    
    :param slhafile: file with mass spectrum and branching ratios and
                     optionally with cross-sections
    :param Xsec: optionally a dictionary with cross-sections for pair
                 production, by default reading the cross sections 
                 from the SLHA file.
    :param XsecsInfo: information about the cross-sections (sqrts, order and
           label). Only relevant for Xsec=None (reading from slha file). If defined 
           as input or in crossSection.XSectionInfo restricts the 
           cross-sections values in the SLHA file to the ones in XsecsInfo. 
           If not defined, it will be generated from the SLHA file and stored in 
           crossSection.XSectionInfo. Only generated if cross-sections are read 
           from SLHA file and not previously created
    :param sigcut: minimum sigma*BR to be generated, by default sigcut = 0.1 fb
    :param doCompress: turn mass compressed topologies on/off
    :param doInvisible: turn invisibly compressed topologies on/off
    :param minmassgap: maximum value for considering two R-odd particles
                       degenerate (only revelant for doCompress=True)        
    :returns: TopologyList
     
    
---Code snippet: def _getDictionariesFromSLHA(slhafile):

---Doc string: 
    Create mass and BR dictionaries from an SLHA file.
    Ignore decay blocks with R-parity violating or unknown decays
    
    
-----------File: validation/plots_closure/plotExcluded.py
No doc strings
-----------File: tools/externalNllFast.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: externalNllFast
   :synopsis: Wrapper for all nllfast versions.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: class ExternalNllFast(ExternalTool):

---Doc string: 
    An instance of this class represents the installation of nllfast.
    
    
---Code snippet:     def __init__(self, sqrts, nllfast_version, test_params, test_condition):

---Doc string: 
        :param sqrts: sqrt of s, in TeV, as an integer,
        :param nllfast_version: version of the nllfast tool
        :param test_params: what are the test params we need to run things with?
        :param test_condition: the line that should be the last output line when
        running executable
        :src_path: the path of the source code, for compilation
        
        
---Code snippet:     def compile(self):

---Doc string: 
        Try to compile nllfast.
        
        
---Code snippet:     def fetch(self):

---Doc string: 
        Fetch and unpack tarball.
        
        
---Code snippet:     def unlink(self, inputFile):

---Doc string: 
        Remove inputFile.out 
        
        
---Code snippet:     def run_(self, params):

---Doc string: 
        Execute nllfast7.
        
        :params params: parameters used (e.g. gg cteq5 .... )
        :returns: stdout and stderr, or error message
        
        
---Code snippet:     def run(self, process, pdf, squarkmass, gluinomass):

---Doc string: 
        Execute nllfast.
        
        :params process: which process: st, sb, gg, gdcpl, sdcpl, ss, sg, tot
        :params pdf: cteq=cteq6, mstw2008 
        :params squarkmass: squarkmass, None if squark decoupled
        :params gluinomass: gluinomass, None if gluino decoupled
        :returns: stdout and stderr, or error message
        
        
---Code snippet:     def checkInstallation(self):

---Doc string: 
        Checks if installation of tool is valid by looking for executable and
        executing it.
        
        
---Code snippet: class ExternalNllFast7(ExternalNllFast):

---Doc string: 
    An instance of this class represents the installation of nllfast 7.
    
    
---Code snippet: class ExternalNllFast8(ExternalNllFast):

---Doc string: 
    An instance of this class represents the installation of nllfast 8.
    
    
---Code snippet: class ExternalNllFast13(ExternalNllFast):

---Doc string: 
    An instance of this class represents the installation of nllfast 13.
    
    
---Code snippet: class ExternalNllFast14(ExternalNllFast):

---Doc string: 
    An instance of this class represents the installation of nllfast 14.
    
    
---Code snippet: class ExternalNllFast33(ExternalNllFast):

---Doc string: 
    An instance of this class represents the installation of nllfast 33.
    
    
-----------File: experiment/__init__.py
---Code snippet: NOT FOUND
---Doc string: 
This package is intended to contain everything that has to do with the
experimental results.


-----------File: smodels/validation/plots_closure/plotExcludedTChiChipmSlepStau095.py
No doc strings
-----------File: smodels/experiment/experimentExceptions.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: experiment.experimentExceptions
   :synopsis: Provides exception classes for the experiment package.
    
.. moduleauthor:: Wolfgang Magerl <wolfgang.magerl@gmail.com>
    

---Code snippet: class MetaInfoError(Exception):

---Doc string: 
    Exception class that is raised when a meta info field cannot be found.
    
    
-----------File: smodels/tests/testSlhaChecks.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: testSlhaChecks
   :synopsis: Tests the slha checker

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>
.. moduleauthor:: Ursula Laa <Ursula.Laa@assoc.oeaw.ac.at>


-----------File: experiment/smsInterpolation.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: experiment.smsInterpolation
   :synopsis: smsInterpolation is called by smsResults.getSmartUpperLimit. UpperLimit
       takes arbitrary input masses and checks if there is a corresponding upper
       limit for the given analysis and topology. The upper limit is returned in
       'pb'. If several histograms with different x-values are available, an
       interpolation is performed.

.. moduleauthor:: Ursula Laa <Ursula.Laa@assoc.oeaw.ac.at>


---Code snippet: def upperLimit(analysis, topology, masses, run=None):

---Doc string: 
    Return upper limit for analysis-topology for given masses. 
    
    :param masses: list of masses, with (mother, intermediate(s), LSP). For
           intermediate masses: if possible do interpolation over upper limits for
           different x-values. If interpolation is not possible: check if masses are
           comparable to the assumptions in the histogram.
    
    
---Code snippet: def _getHistName(topo, mz):

---Doc string: 
    Build histogram name for given topology and mz information.
    
    :param mz: given in the axes-information
    
    
---Code snippet: def _doGridData(analysis, topology, masses, dPar, run=None):

---Doc string: 
    Create np.array and uses scipy.griddata function for analysis-topology.
    
    
---Code snippet: def _getAxis(w, a):

---Doc string: 
    Find according index in the masses-list for w == x, y.
    
    Use the axes-information a == (mx - my).
    
    
---Code snippet: def _getxval(mx, my, mz, mass=False):

---Doc string: 
    Calculate x-value for one point.
    
    If mass == True is selected, return intermediate mass instead of x-value.
    
    :param mx: Mother-mass
    :param my: LSP-mass
    :param mz: information on the intermediate mass as given in the
    axes-information.
    
    
---Code snippet: def _compareMasses(masses, d):

---Doc string: 
    Check if input masses are comparable to masses in the histogram.
    
    Masses are comparable corresponding to the information given in
    axes-dictionary d.
    
    
---Code snippet: def _getIndex(ls, second=False):

---Doc string: 
    Find index of list element with maximum value.
    
    If the last element is the maximum, return -1. If second == True, find
    second largest list element.
    
    
-----------File: validation/plots_closure/plotExcludedTChiWZ.py
No doc strings
-----------File: smodels/validation/plots_closure/addMetadata.py
No doc strings
-----------File: smodels/theory/particleNames.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: ParticleNames
   :synopsis: Provides functions for getting particle names from pdg ids, and
              other helpers.

.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>


---Code snippet: def getName(pdg):

---Doc string: 
    Convert pdg number to particle name according to the dictionaries rOdd and
    rEven.

    :type pdg: int
    :returns: particle name (e.g. gluino, mu-, ...)
    
    
---Code snippet: def getPdg(name):

---Doc string: 
    Convert a name to the pdg number according to the dictionaries rOdd and
    rEven.

    :type name: string
    :returns: particle pdg; None, if name could not be resolved
    
    
---Code snippet: def elementsInStr(instring):

---Doc string: 
    Parse instring and return a list of elements appearing in instring.
    
    instring can also be a list of strings.
    
    :returns: list of elements appearing in instring in string format
    
    
---Code snippet: def vertInStr(instring):

---Doc string: 
    Parses instring (or a list of strings) and returns the list of particle
    vertices appearing in instring.
    
    
---Code snippet: def simParticles(ptype1, ptype2, useDict=True):

---Doc string: 
    Compares 2 particle names or 2 nested name arrays. Allows for dictionary
    labels (Ex: L = l, l+ = l, l = l-,...). For the last nested level ignore
    particle ordering. FIXME nesting? 
 
    :param ptype1: first (nested) list of particle names, e.g. ['l','jet']
    :param ptype2: second (nested) list of particle names 
    :param useDict: use the translation dictionary, i.e. allow e to stand for
                    e+ or e-, l+ to stand for e+ or mu+, etc 
    :returns: boolean
    
    
-----------File: tools/xsecComputer.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: xsecComputer
   :synopsis: Computation of reference ("theory") production cross sections.

.. moduleauthor:: Suchita Kulkarni <suchita.kulkarni@gmail.com>
.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>
.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: def computeXSec(sqrts, maxOrder, nevts, slhafile, lhefile=None, unlink=True, loFromSlha=None ):

---Doc string: 
    Run pythia and compute SUSY cross-sections for the input SLHA file.

    :param sqrts: sqrt{s} to run Pythia
    :param maxOrder: maximum order to compute the cross-section
                if maxOrder = 0, compute only LO pythia xsecs
                if maxOrder = 1, apply NLO K-factors from NLLfast (if available)
                if maxOrder = 2, apply NLO+NLL K-factors from NLLfast (if available)
    :param nevts: number of events for pythia run
    :param slhafile: SLHA file
    :param lhefile: LHE file. If None, do not write pythia output to file. If
                    file does not exist, write pythia output to this file name. If
                    file exists, read LO xsecs from this file (does not run pythia).
    :param unlink: Clean up temp directory after running pythia

    :param loFromSlha: If True, uses the LO xsecs from the SLHA file to compute the
                       higher order xsecs

    :returns: XSectionList object

    
---Code snippet: def addXSecToFile(xsecs, slhafile, comment=None, complain=True):

---Doc string: 
    Write cross-sections to an SLHA file.
    
    :param xsecs: a XSectionList object containing the cross-sections
    :param slhafile: target file for writing the cross-sections in SLHA format
    :param comment: optional comment to be added to each cross-section block
    :param complain: complain if there are already cross sections in file

    
---Code snippet: def xsecToBlock(xsec, inPDGs=(2212, 2212), comment=None):

---Doc string: 
    Generate a string for a XSECTION block in the SLHA format from a XSection
    object.

    :param inPDGs: defines the PDGs of the incoming states
                   (default = 2212,2212)

    :param comment: is added at the end of the header as a comment

    
---Code snippet: def runPythia(slhafile, nevts, sqrts, lhefile=None, unlink=True ):

---Doc string: 
    Execute pythia_lhe with n events, at sqrt(s)=sqrts.

    :param slhafile: input SLHA file
    :param nevts: number of events to be generated
    :param sqrts: center of mass sqrt{s} (in TeV)
    :param lhefile: option to write LHE output to file; ff None, do not write
                    output to disk.
    :param unlink: Clean up temp directory after running pythia
    :returns: file object with the LHE events

    
---Code snippet:     box = toolBox.ToolBox()
    tool = box.get("pythia6")
    # Check if template config file exists
    tool.reset()
    tool.replaceInCfgFile({"NEVENTS": nevts, "SQRTS":1000 * sqrts})
    tool.setParameter("MSTP(163)", "6")
    if unlink==False:
        logger.info ( "keeping temporary directory at %s" % tool.tempDirectory() )
    lhedata = tool.run(slhafile, do_unlink=unlink )
    if not "<LesHouchesEvents" in lhedata:
        logger.error("LHE events not found in pythia output")
        import sys
        sys.exit()
    # Generate file object with lhe events
    if lhefile:
        lheFile = open(lhefile, 'w')
        lheFile.write(lhedata)
        lheFile.close()
        lheFile = open(lhefile, 'r')
    else:
        # Create memory only file object
        lheFile = cStringIO.StringIO(lhedata)
    return lheFile
if __name__ == "__main__":

---Doc string: 
    Compute the cross section of a given SLHA file.

    
-----------File: smodels/theory/setPath.py
---Code snippet: #!/usr/bin/python

---Doc string: 
.. module:: setPath
   :synopsis: Sets the path such that e.g. from smodels.tools import toolBox works.
              correctly. Called as a script, the path is printed.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: def configure():

---Doc string: 
    Get the path name of this file, remove set_path.py, remove the last
    subdir.

    The remaining string should be the base path name.

    
---Code snippet:     base = os.path.dirname(os.path.realpath(inspect.getabsfile(configure)))
    pos = base.rfind("/theory")
    base = base[:pos + 1]
    sys.path.append(base)
    # sys.path.append(base[:-9])
    return base
configure()
if __name__ == "__main__":

---Doc string: 
    Called as a script, print out the path.

    
-----------File: smodels/particles.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: particles
   :synopsis: Defines the list of R-even and R-odd particles to be used.

.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>

   :parameter rOdd: dictionary with PDG codes for the rOdd (Z2-odd) particles and their respective labels
   :parameter rEven: dictionary with PDG codes for the rEven (Z2-eveb) particles and their respective labels
   :parameter ptcDic: dictionary with inclusive labels to help defining group of particles in the analysis database
   
   HOW TO ADD NEW PARTICLES: simply add a new entry in rOdd (rEven) if the particle is Z2-odd (Z2-even).
   For now all decays of Z2-even particles are ignored. Z2-odd particles are decayed assuming Z2 convervation.


-----------File: tools/uniqueLogFilter.py
---Code snippet: import logging

---Doc string: 
.. module:: uniqueLogFilter
   :synopsis: Contains a stolen code snippet for a logging filter to
       have identical log messages appear only once.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: class UniqueFilter(logging.Filter):

---Doc string: Messages are allowed through just once.
    The 'message' includes substitutions, but is not formatted by the 
    handler. If it were, then practically all messages would be unique!
    stolen from: http://code.activestate.com/recipes/412552-using-the-logging-module/
    
---Code snippet:     def reset(self):

---Doc string: Act as if nothing has happened.
---Code snippet:     def filter(self, rec):

---Doc string: logging.Filter.filter performs an extra filter on the name.
---Code snippet:     def __is_first_time(self, rec):

---Doc string: Emit a message only once.
-----------File: theory/topology.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: theory.Topology
   :synopsis: Provides a Topology class and a TopologyList collection type.

.. moduleauthor:: Wolfgang Magerl <wolfgang.magerl@gmail.com>


---Code snippet: class Topology(object):

---Doc string: 
    An instance of this class represents a topology.

    
---Code snippet:     def __init__(self, elements=None):

---Doc string: 
        Constructor.

        If elements is defined, create the topology from it. If elements it is
        a list, all elements must share a common global topology.

        
---Code snippet:     def __str__(self):

---Doc string: 
        Return string with numbers of particles per vertex, e.g.
        [1,0],[2,1,0]

        
---Code snippet:     def isEqual(self, other, order=False):

---Doc string: 
        Check for equality of two topologies.

        If order == False and each topology has two branches, ignore branch
        ordering.

        :returns: True, if both topologies have the same number of vertices and
                  particles.

        
---Code snippet:     def checkConsistency(self):

---Doc string: 
        Perform a consistency check.

        The number of vertices and insertions per vertex is redundant
        information in a topology, so we can perform an internal consistency
        check.

        
---Code snippet:     def describe(self):

---Doc string: 
        Create a detailed description of the topology.

        
---Code snippet:     def getElements(self):

---Doc string: 
        Get list of elements of the topology.

        
---Code snippet:     def addElement(self, newelement):

---Doc string: 
        Add an Element object to the elementList.

        For all the pre-existing elements, which match the new element, add
        weight. If no pre-existing elements match the new one, add it to the
        list. If order == False, try both branch orderings.

        
---Code snippet:     def _getTinfo(self):

---Doc string: 
        Return a dictionary with the topology number of vertices and vertparts.

        
---Code snippet:     def getTotalWeight(self):

---Doc string: 
        Return the sum of all elements weights.

        
---Code snippet: class TopologyList(Printer):

---Doc string: 
    An instance of this class represents an iterable collection of topologies.

    
---Code snippet:     def __init__(self, topologies=[]):

---Doc string: 
        Add topologies sequentially, if provided.

        
---Code snippet:     def addList(self, topoList):

---Doc string: 
        Adds topologies in topoList using the add method.

        
---Code snippet:     def describe(self):

---Doc string: 
        Returns string with basic information about the topology list.

        
---Code snippet:     def add(self, newTopology):

---Doc string: 
        Check if elements in newTopology matches an entry in self.topos.

        If it does, add weight. If the same topology exists, but not the same
        element, add element. If neither element nor topology exist, add the
        new topology and all its elements.

        :type topo: Topology

        
---Code snippet:     def getTotalWeight(self):

---Doc string: 
        Return the sum of all topologies total weights.

        
---Code snippet:     def getElements(self):

---Doc string: 
        Return a list with all the elements in all the topologies.

        
---Code snippet:     def formatData(self):

---Doc string: 
        Select data preparation method through dynamic binding.

        
-----------File: recipes/setPath.py
---Code snippet: #!/usr/bin/python

---Doc string:                                                                                    
.. module:: setPath
   :synopsis: Sets the path such that e.g. "from tools import rootTools" works
   correctly. Called as a script, the path is printed.
                                                                                      
.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>             
                                                                                      

---Code snippet: def configure():

---Doc string: 
    Get the path name of this file, remove set_path.py, remove the last
    subdir.
    
    The remaining string should be the base path name.
    
    
---Code snippet:     base = os.path.dirname(os.path.realpath(inspect.getabsfile(configure)))
    pos = base.rfind("/")
    base = base[:pos + 1]
    sys.path.append(base)
    # sys.path.append(base[:-9])
    return base
configure()
if __name__ == "__main__":

---Doc string: 
    Called as a script, print out the path.
    
    
-----------File: smodels/runSModelS.py
No doc strings
-----------File: tests/testAsciiGraph.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: testAsciiGraph
   :synopsis: Tests the ascii grapher.
              Depends also on lheReader, lheDecomposer.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet:     def orig(self):
        return 

---Doc string:  /------------\\
 |    q  q    |
 |    \ /     |
 | ----*----  |
 | ----*----  |
 |    / \     |
 |    q  q    |
 \------------/

---Code snippet:     def testGraph(self):

---Doc string:  draw ascii graph 
-----------File: tools/toolBox.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: toolBox
   :synopsis: Contains a singleton-like class that keeps track of all external tools

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: class ToolBox(object):

---Doc string: 
    A singleton-like class that keeps track of all external tools.
    
    
---Code snippet:     def initSingleton(self):

---Doc string: 
        Intialize singleton instance (done only once for the entire class).
        
        
---Code snippet:     def add(self, instance):

---Doc string: 
        Adds a tool by passing an instance to this method.
        
        
---Code snippet:     def listOfTools(self):

---Doc string: 
        Returns a simple list with the tool names.
        
        
---Code snippet:     def get(self, tool, verbose=True):

---Doc string: 
        Gets instance of tool from the toolbox.
        
        
-----------File: tests/testToolBox.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: testTx
   :synopsis: Tests with Tx slha input files.
    
.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>
    

-----------File: smodels/validation/plots_closure/plotExcludedT2tt.py
No doc strings
-----------File: smodels/validation/plots_closure/plotExcludedT5WW050.py
No doc strings
-----------File: validation/SMSclosure.py
No doc strings
-----------File: experiment/smsAnalysisFactory.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: experiment.smsAnalysisFactory
   :synopsis: Create a list of analysis objects from a results database.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>
.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>


---Code snippet: def load(analyses=None, topologies=None, sqrts=[7, 8], usePrivate=None):

---Doc string: 
    Create an analysis objects from the info given in the SMS results database.
)
    :param analyses: If a list of analyses is passed, create only objects for
                     these analyses (the database naming convention is used).
    :param topologies: If a list of topologies is passed, only these topologies
                       are considered.
    :param sqrts: Array of center-of-mass energies of the analyses that are to
                  be considered.
    :param usePrivate: Include analyses flagged as private.
    :returns: list of analyses
    
    
---Code snippet: def _getRealTopo(tx):

---Doc string: 
    Get real topology, e.g., T3w025 -> T3w, etc.
    
    
---Code snippet: def _getElementsEffs(constraint,conditions):

---Doc string: 
    Generate a dictionary of elements with their simple efficiencies as values.    
    Efficiencies are = 1. if the element appears in the constraint or conditions.
    
    
---Code snippet: def _getArray(constraint):

---Doc string: 
    Get number of vertices, branches and insertions from a constraint string.
    
    This maps, e.g.,
    2*([[['L'],['L']],[['L'],['nu']]] + [[['L'],['L']],[['nu'],['L']]])
    to
    [[['L'],['L']],[['L'],['nu']]]
    
    
-----------File: smodels/theory/branch.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: theory.branch
   :synopsis: Module holding the branch class and methods.
        
.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>
        

---Code snippet: class Branch(object):

---Doc string: 
    An instance of this class represents a branch.
    
    A branch-element can be constructed from a string (e.g., ('[b,b],[W]').
    
    
---Code snippet:     def __str__(self):

---Doc string: 
        Create the canonical SModels description of the Branch.
        
        
---Code snippet:     def isEqual(self, other, useDict=True):

---Doc string:  Compare the branch with other. If particles are similar
        and masses are equal, return True. Otherwise, return False.        
        
---Code snippet:     def copy(self):

---Doc string: 
        Generate an independent copy of self.
        
        Faster than deepcopy.
        
        
---Code snippet:     def getLength(self):

---Doc string: 
        Returns the branch length (= number of R-odd masses).
        
        
---Code snippet:     def _addDecay(self, br, massDictionary):

---Doc string: 
        Generate a new branch adding a 1-step cascade decay.
        
        This is described by the br object, with particle masses given by
        massDictionary.
        
        
---Code snippet:     def decayDaughter(self, brDictionary, massDictionary):

---Doc string: 
        Generate a list of all new branches generated by the 1-step cascade
        decay of the current branch daughter.
        
        
---Code snippet: def decayBranches(branchList, brDictionary, massDictionary,
                  sigcut=addunit(0., 'fb')):

---Doc string: 
    Decay all branches from branchList until all R-odd particles have decayed.
    
    :param branchList: list of Branch() objects containing the initial mothers
    :param brDictionary: branching ratio dictionary for all particles appearing
                         in the decays
    :param massDictionary: mass dictionary for all particles appearing in the
                           decays
    :param sigcut: minimum sigma*BR to be generated, by default sigcut = 0.
                   (all branches are kept)
    
    
-----------File: smodels/validation/database/2012/SUS12011/sms.py
No doc strings
-----------File: smodels/lixo.py
No doc strings
-----------File: tests/runCompleteTestSuite.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: runCompleteTestSuite
   :synopsis: Runs all test suites.
    
.. moduleauthor:: Wolfgang Magerl <wolfgang.magerl@gmail.com>
.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com> 
    

---Code snippet: def testScript ( filename ):

---Doc string:  is filename of the form 'test*py'? 
-----------File: smodels/installation.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: installation
   :synopsis: a module for returning installation paths and version numbers.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: def installDirectory():

---Doc string: 
    Return the software installation directory, by looking at location of this
    method.
    
    
---Code snippet: def pythonDirectory():

---Doc string: 
    Return the python installation directory, by looking at location of this
    method. Same as installDirectory(), but trailing "smodels/" removed.
    
    
---Code snippet: def version(astuple=False):

---Doc string: 
    Print version number of the SModelS framework.
    
    
---Code snippet: def license():

---Doc string: 
    Print license information of the SModelS framework.
    
    
---Code snippet: def banner():

---Doc string: 
    Print SModelS banner.
    
    
---Code snippet: def printHelp():

---Doc string: 
    Print usage information of this module.
    
    
-----------File: smodels/validation/plots_closure/plotExcludedTSlepSlep.py
No doc strings
-----------File: tools/rcFile.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: rcFile
   :synopsis: When imported, ~/.smodelsrc is parsed.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: def yesno(B):

---Doc string: 
    TODO: write docstring
    
    
---Code snippet: def parseRCFile():

---Doc string: 
    TODO: write docstring
    
    
---Code snippet:     import setPath
    rcfile = os.path.expanduser("~") + "/.smodelsrc"
    exists = os.path.exists(rcfile)
    if exists:
        execfile(rcfile)
        return True
    return False
parseRCFile()
if __name__ == "__main__":

---Doc string: 
    Check if there is a smodelsrc file.
    
    
-----------File: validation/plots_closure/plotExcludedT1tttt.py
No doc strings
-----------File: tests/testXSecComputer.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: testXSecComputer
   :synopsis: Compares the output of XSecComputer with a given value.
    
.. moduleauthor:: Wolfgang Magerl <wolfgang.magerl@gmail.com>
.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>
    

---Code snippet:     def testLO(self):

---Doc string:  test the computation of LO cross section 
---Code snippet:     def testNLL (self):

---Doc string:  test the computation of NLL cross section 
-----------File: smodels/validation/plots_closure/plotExcluded.py
No doc strings
-----------File: smodels/tools/externalPythia6.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: externalPythia6
   :synopsis: Wrapper for pythia6.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: class ExternalPythia6(ExternalTool):

---Doc string: 
    An instance of this class represents the installation of pythia6.
    
    
---Code snippet:     def __init__(self,
                 config_file="<install>/etc/pythia.card",
                 executable_path="<install>/tools/external/pythia6/pythia_lhe",
                 src_path="<install>/pythia6/", verbose=False):

---Doc string:  
        :param config_file: location of the config file, full path; copy this
        file and provide tools to change its content and to provide a template
        :param executable_path: location of executable, full path (pythia_lhe)
        
        
---Code snippet:     def reset(self):

---Doc string: 
        Copy the original config file again.
        
        
---Code snippet:     def checkFileExists(self, inputFile):

---Doc string: 
        Check if file exists, raise an IOError if it does not.
        
        :returns: absolute file name if file exists.
        
        
---Code snippet:     def tempDirectory(self):

---Doc string: 
        Return the temporary directory name.
        
        
---Code snippet:     def __str__(self):

---Doc string:  
        Describe the current status 

        
---Code snippet:     def unlink(self, unlinkdir=True):

---Doc string: 
        Remove temporary files.
        
        :param unlinkdir: remove temp directory completely
        
        
---Code snippet:     def replaceInCfgFile(self, replacements={"NEVENTS": 10000, "SQRTS":8000}):

---Doc string: 
        Replace strings in the config file by other strings, similar to
        setParameter.

        This is introduced as a simple mechanism to make changes to the
        parameter file.
        
        :param replacements: dictionary of strings and values; the strings will
                             be replaced with the values; the dictionary keys 
                             must be strings present in the config file
        
        
---Code snippet:     def setParameter(self, param="MSTP(163)", value=6):

---Doc string: 
        Modifies the config file, similar to .replaceInCfgFile.
        
        It will set param to value, overwriting possible old values.
        
        
---Code snippet:     def run(self, slhafile, cfgfile=None, do_unlink=True):

---Doc string: 
        Run Pythia.
        
        :param slhafile: SLHA file
        :param cfgfile: optionally supply a new config file; if not supplied,
                        use the one supplied at construction time; 
                        this config file will not be touched or copied;  
                        it will be taken as is
        :param do_unlink: clean up temporary files after run?
        :returns: stdout and stderr, or error message
        
        
---Code snippet:     def compile(self):

---Doc string: 
        Compile pythia_lhe.
        
        
---Code snippet:     def fetch(self, verbose=True):

---Doc string: 
        Fetch and unpack tarball.
        
        
---Code snippet:     def checkInstallation(self):

---Doc string: 
        Check if installation of tool is correct by looking for executable and
        running it.
        
        
-----------File: smodels/checkDocStr.py
---Code snippet: codesnippetTags = ['def','class']
info = {}
for fname in matches:
    info[fname] = {'docstrings' : [], 'codesnippet' : []}
    fcheck = open(fname,'r')
    fdata = fcheck.read().lstrip()
    if fdata[0] == '

---Doc string: ': idoc = 'evenBlocks'
    else: idoc = 'oddBlocks'
    fdata = fdata.split('
-----------File: smodels/validation/SMSclosure.py
No doc strings
-----------File: tools/nllFast.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: nllFast
   :synopsis: This module provides methods to access the nllfast grid and
              compute k-factors (when available) to SUSY pair 
              production cross-sections.

.. moduleauthor:: Suchita Kulkarni <suchita.kulkarni@gmail.com>
.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>


---Code snippet: def getKfactorsFor(pIDs, sqrts, slhafile, pdf='cteq'):

---Doc string: 
    Read the NLLfast grid and returns a pair of k-factors (NLO and NLL) for the
    pair.

    :returns: k-factors = None, if NLLfast does not contain the process; uses
              the slhafile to obtain the SUSY spectrum.
    
    
---Code snippet: def getProcessName(pIDs):

---Doc string: 
    Return the process name (in NLLfast notation) for the pair production of
    pIDs.
    
    :returns: None, if the particle ID pair is not contained in NLLfast
    
    
---Code snippet: def runNLLfast(nll_run, nllpath):

---Doc string: 
    Execute NLLfast with command nll_run at nllpath.
    
    :returns: NLLfast output as a string
    
    
---Code snippet: def getKfactorsFrom(output):

---Doc string: 
    Read NLLfast output and return the k-factors.
    
    
---Code snippet: def interpolateKfactors(kFacsVector, xval):

---Doc string: 
    Interpolate a list of k-factor  values from
    kFacsVector = [[x0,[k1,k2,..]], [x1,[k1,k2,..],...].
    
    :returns: list of interpolated k-factor values at x-value xval
    
    
---Code snippet: def getDecoupledKfactors(nllpath,process,energy,pdf,mass):

---Doc string: 
    Compute k-factors in the decoupled (squark or gluino) regime for the process.
    If a decoupled grid does not exist for the process, return None
    
---Code snippet:     if process != 'sb' and process != 'gg': return None
    elif process == 'sb': process_dcpl = 'sdcpl'
    elif process == 'gg': process_dcpl = 'gdcpl'    
    nll_run = "./nllfast_" + energy + " %s %s %s" % \
                      (process_dcpl, pdf, mass)
    nll_output = runNLLfast(nll_run, nllpath)
    if "K_NLO" in nll_output:
        return getKfactorsFrom(nll_output)
    else: return None
if __name__ == "__main__":

---Doc string: 
    Calculate k factors for a pid pair.
    
    
-----------File: tools/slhaChecks.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
    .. module:: slhaChecks
       :synopsis: Check SLHA file for integrity.

        .. moduleauthor:: Ursula Laa <Ursula.Laa@assoc.oeaw.ac.at>
        .. moduleauthor:: Veronika Magerl <v.magerl@gmx.at>
        .. moduleauthor:: Suchita Kulkarni <suchita.kulkarni@gmail.com>


---Code snippet: class SlhaStatus(Printer):

---Doc string: 
    An instance of this class represents the status of an SLHA file.
    The output status is 0 if the file is not checked, 1 if the check is ok
    The final status is -1 in case of a physical problem, e.g. charged LSP,
    and -2 in case of formal problems, e.g. missing decay blocks, in the file
    The parameter maxFlightlength is specified in meters. 
    
---Code snippet:     def read(self):

---Doc string: 
        Get pyslha output object.
        
        
---Code snippet:     def evaluateStatus(self):

---Doc string: 
        Get status summary from all performed checks.

        :returns: a status flag and a message for explanation

        
---Code snippet:     def checkDecayBlock(self, findMissingDecays):

---Doc string: 
        Check if there is a decay table for each particle with pid > 50 given
        in the mass block.
        
        
---Code snippet:     def checkCtau(self, checkFlightlength):

---Doc string: 
        Check if c*tau of NLSP is larger than given maximum.
        Report error for long lived, charged NLSP.

        
---Code snippet:     def findEmptyDecay(self, findEmpty):

---Doc string: 
        Find all particles that are considered stable in SModelS.
        
        Stable particle means that no branching ratios are given in the
        decay table of the particle in the slha file.
        
        
---Code snippet:     def hasXsec(self, checkXsec):

---Doc string: 
        Check if XSECTION table is present in the slha file.
        
        
---Code snippet:     def testLSP(self, checkLSP):

---Doc string: 
        Check if lsp is charged.
        
        
---Code snippet:     def findLSP(self, returnmass=None):

---Doc string: 
        Find lightest particle with pid > 50.
        
        :returns: pid, mass of the lsp, if returnmass == True
        
        
---Code snippet:     def getLifetime(self, pid, ctau=False):

---Doc string: 
        Compute lifetime from decay-width for a particle with pid.
        
        
---Code snippet:     def sumBR(self, pid):

---Doc string: 
        Calculate the sum of all branching ratios for particle with pid.
        
        
---Code snippet:     def deltaMass(self, pid1, pid2):

---Doc string: 
        Calculate mass splitting between particles with pid1 and pid2.
        
        
---Code snippet:     def findNLSP(self, returnmass = None):

---Doc string: 
        Find second lightest particle with pid >= 50.
        
        :returns: pid ,mass of the NLSP, if returnmass == True
        
        
---Code snippet:     def getDecayWidths(self):

---Doc string: 
        Get all decay-widths as a dictionary {pid: width}.
        
        
---Code snippet:     def getDecayWidth(self, pid):

---Doc string: 
        Get the decay-width for particle with pid, if it exists.
        
        
---Code snippet:     def massDiffLSPandNLSP(self):

---Doc string: 
        Get the mass difference between the lsp and the nlsp.
        
        
---Code snippet:     def findDisplacedVertices(self, findDisplaced):

---Doc string: 
        find meta-stable particles that decay via leptons or higgs
        
---Code snippet:     def getXSEC(self, pid, sqrts=8000.):

---Doc string: 
        get crosssection for pair production, read last line
        
---Code snippet:     def degenerateChi(self):

---Doc string: 
        Check if chi01 is lsp and chipm1 is NLSP. If so, check mass splitting.
        This function is not used, the limit is arbitrary.

        
---Code snippet: class Qnumbers:

---Doc string: 
    An instance of this class represents quantum numbers.
    
    Get quantum numbers (spin*2, electrical charge*3, color dimension) from "model"_qNumbers.
    
    
-----------File: smodels/tools/xsecComputer.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: xsecComputer
   :synopsis: Computation of reference ("theory") production cross sections.

.. moduleauthor:: Suchita Kulkarni <suchita.kulkarni@gmail.com>
.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>
.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: def computeXSec(sqrts, maxOrder, nevts, slhafile, lhefile=None, unlink=True, loFromSlha=None ):

---Doc string: 
    Run pythia and compute SUSY cross-sections for the input SLHA file.

    :param sqrts: sqrt{s} to run Pythia
    :param maxOrder: maximum order to compute the cross-section
                if maxOrder = 0, compute only LO pythia xsecs
                if maxOrder = 1, apply NLO K-factors from NLLfast (if available)
                if maxOrder = 2, apply NLO+NLL K-factors from NLLfast (if available)
    :param nevts: number of events for pythia run
    :param slhafile: SLHA file
    :param lhefile: LHE file. If None, do not write pythia output to file. If
                    file does not exist, write pythia output to this file name. If
                    file exists, read LO xsecs from this file (does not run pythia).
    :param unlink: Clean up temp directory after running pythia

    :param loFromSlha: If True, uses the LO xsecs from the SLHA file to compute the
                       higher order xsecs

    :returns: XSectionList object

    
---Code snippet: def addXSecToFile(xsecs, slhafile, comment=None, complain=True):

---Doc string: 
    Write cross-sections to an SLHA file.
    
    :param xsecs: a XSectionList object containing the cross-sections
    :param slhafile: target file for writing the cross-sections in SLHA format
    :param comment: optional comment to be added to each cross-section block
    :param complain: complain if there are already cross sections in file

    
---Code snippet: def xsecToBlock(xsec, inPDGs=(2212, 2212), comment=None):

---Doc string: 
    Generate a string for a XSECTION block in the SLHA format from a XSection
    object.

    :param inPDGs: defines the PDGs of the incoming states
                   (default = 2212,2212)

    :param comment: is added at the end of the header as a comment

    
---Code snippet: def runPythia(slhafile, nevts, sqrts, lhefile=None, unlink=True ):

---Doc string: 
    Execute pythia_lhe with n events, at sqrt(s)=sqrts.

    :param slhafile: input SLHA file
    :param nevts: number of events to be generated
    :param sqrts: center of mass sqrt{s} (in TeV)
    :param lhefile: option to write LHE output to file; ff None, do not write
                    output to disk.
    :param unlink: Clean up temp directory after running pythia
    :returns: file object with the LHE events

    
---Code snippet:     box = toolBox.ToolBox()
    tool = box.get("pythia6")
    # Check if template config file exists
    tool.reset()
    tool.replaceInCfgFile({"NEVENTS": nevts, "SQRTS":1000 * sqrts})
    tool.setParameter("MSTP(163)", "6")
    if unlink==False:
        logger.info ( "keeping temporary directory at %s" % tool.tempDirectory() )
    lhedata = tool.run(slhafile, do_unlink=unlink )
    if not "<LesHouchesEvents" in lhedata:
        logger.error("LHE events not found in pythia output")
        import sys
        sys.exit()
    # Generate file object with lhe events
    if lhefile:
        lheFile = open(lhefile, 'w')
        lheFile.write(lhedata)
        lheFile.close()
        lheFile = open(lhefile, 'r')
    else:
        # Create memory only file object
        lheFile = cStringIO.StringIO(lhedata)
    return lheFile
if __name__ == "__main__":

---Doc string: 
    Compute the cross section of a given SLHA file.

    
-----------File: smodels/validation/plots_closure/plotExcludedT2CMS.py
No doc strings
-----------File: tools/externalPythia6.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: externalPythia6
   :synopsis: Wrapper for pythia6.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: class ExternalPythia6(ExternalTool):

---Doc string: 
    An instance of this class represents the installation of pythia6.
    
    
---Code snippet:     def __init__(self,
                 config_file="<install>/etc/pythia.card",
                 executable_path="<install>/tools/external/pythia6/pythia_lhe",
                 src_path="<install>/pythia6/", verbose=False):

---Doc string:  
        :param config_file: location of the config file, full path; copy this
        file and provide tools to change its content and to provide a template
        :param executable_path: location of executable, full path (pythia_lhe)
        
        
---Code snippet:     def reset(self):

---Doc string: 
        Copy the original config file again.
        
        
---Code snippet:     def checkFileExists(self, inputFile):

---Doc string: 
        Check if file exists, raise an IOError if it does not.
        
        :returns: absolute file name if file exists.
        
        
---Code snippet:     def tempDirectory(self):

---Doc string: 
        Return the temporary directory name.
        
        
---Code snippet:     def __str__(self):

---Doc string:  
        Describe the current status 

        
---Code snippet:     def unlink(self, unlinkdir=True):

---Doc string: 
        Remove temporary files.
        
        :param unlinkdir: remove temp directory completely
        
        
---Code snippet:     def replaceInCfgFile(self, replacements={"NEVENTS": 10000, "SQRTS":8000}):

---Doc string: 
        Replace strings in the config file by other strings, similar to
        setParameter.

        This is introduced as a simple mechanism to make changes to the
        parameter file.
        
        :param replacements: dictionary of strings and values; the strings will
                             be replaced with the values; the dictionary keys 
                             must be strings present in the config file
        
        
---Code snippet:     def setParameter(self, param="MSTP(163)", value=6):

---Doc string: 
        Modifies the config file, similar to .replaceInCfgFile.
        
        It will set param to value, overwriting possible old values.
        
        
---Code snippet:     def run(self, slhafile, cfgfile=None, do_unlink=True):

---Doc string: 
        Run Pythia.
        
        :param slhafile: SLHA file
        :param cfgfile: optionally supply a new config file; if not supplied,
                        use the one supplied at construction time; 
                        this config file will not be touched or copied;  
                        it will be taken as is
        :param do_unlink: clean up temporary files after run?
        :returns: stdout and stderr, or error message
        
        
---Code snippet:     def compile(self):

---Doc string: 
        Compile pythia_lhe.
        
        
---Code snippet:     def fetch(self, verbose=True):

---Doc string: 
        Fetch and unpack tarball.
        
        
---Code snippet:     def checkInstallation(self):

---Doc string: 
        Check if installation of tool is correct by looking for executable and
        running it.
        
        
-----------File: smodels/validation/plots_closure/plotExcludedT1tttt.py
No doc strings
-----------File: smodels/validation/SMScheck.py
No doc strings
-----------File: validation/plots_closure/plotExcludedT2.py
No doc strings
-----------File: smodels/validation/plots_closure/lixo.py
No doc strings
-----------File: smodels/theory/lheReader.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: LheReader
   :synopsis: Provides a class that creates SMSEvents from LHE files.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: class LheReader(object):

---Doc string: 
    An instance of this class represents a reader for LHE files.
    
    
---Code snippet:     def __init__(self, filename, nmax=None):

---Doc string: 
        Constructor.
        
        :param filename: LHE file name
        :param nmax: When using the iterator, then nmax is the maximum number
        of events to be reader, nmax=None means read till the end of the file.
        If filename is not a string, assume it is already a file object and do
        not open it.
        
        
---Code snippet:     def next(self):

---Doc string: 
        Get next element in iteration.
        
        Needed for the iterator.
        
        
---Code snippet:     def __iter__(self):

---Doc string: 
        Make class iterable.
        
        Allows iterations like 'for a in lhereader: print a'.
        
        
---Code snippet:     def event(self):

---Doc string: 
        Get next event.
        
        :returns: SmsEvent; None if no event is left to be read.
        
        
---Code snippet:     def close(self):

---Doc string: 
        Close the lhe file, if open.
        
        
-----------File: smodels/theory/topology.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: theory.Topology
   :synopsis: Provides a Topology class and a TopologyList collection type.

.. moduleauthor:: Wolfgang Magerl <wolfgang.magerl@gmail.com>


---Code snippet: class Topology(object):

---Doc string: 
    An instance of this class represents a topology.

    
---Code snippet:     def __init__(self, elements=None):

---Doc string: 
        Constructor.

        If elements is defined, create the topology from it. If elements it is
        a list, all elements must share a common global topology.

        
---Code snippet:     def __str__(self):

---Doc string: 
        Return string with numbers of particles per vertex, e.g.
        [1,0],[2,1,0]

        
---Code snippet:     def isEqual(self, other, order=False):

---Doc string: 
        Check for equality of two topologies.

        If order == False and each topology has two branches, ignore branch
        ordering.

        :returns: True, if both topologies have the same number of vertices and
                  particles.

        
---Code snippet:     def checkConsistency(self):

---Doc string: 
        Perform a consistency check.

        The number of vertices and insertions per vertex is redundant
        information in a topology, so we can perform an internal consistency
        check.

        
---Code snippet:     def describe(self):

---Doc string: 
        Create a detailed description of the topology.

        
---Code snippet:     def getElements(self):

---Doc string: 
        Get list of elements of the topology.

        
---Code snippet:     def addElement(self, newelement):

---Doc string: 
        Add an Element object to the elementList.

        For all the pre-existing elements, which match the new element, add
        weight. If no pre-existing elements match the new one, add it to the
        list. If order == False, try both branch orderings.

        
---Code snippet:     def _getTinfo(self):

---Doc string: 
        Return a dictionary with the topology number of vertices and vertparts.

        
---Code snippet:     def getTotalWeight(self):

---Doc string: 
        Return the sum of all elements weights.

        
---Code snippet: class TopologyList(Printer):

---Doc string: 
    An instance of this class represents an iterable collection of topologies.

    
---Code snippet:     def __init__(self, topologies=[]):

---Doc string: 
        Add topologies sequentially, if provided.

        
---Code snippet:     def addList(self, topoList):

---Doc string: 
        Adds topologies in topoList using the add method.

        
---Code snippet:     def describe(self):

---Doc string: 
        Returns string with basic information about the topology list.

        
---Code snippet:     def add(self, newTopology):

---Doc string: 
        Check if elements in newTopology matches an entry in self.topos.

        If it does, add weight. If the same topology exists, but not the same
        element, add element. If neither element nor topology exist, add the
        new topology and all its elements.

        :type topo: Topology

        
---Code snippet:     def getTotalWeight(self):

---Doc string: 
        Return the sum of all topologies total weights.

        
---Code snippet:     def getElements(self):

---Doc string: 
        Return a list with all the elements in all the topologies.

        
---Code snippet:     def formatData(self):

---Doc string: 
        Select data preparation method through dynamic binding.

        
-----------File: theory/setPath.py
---Code snippet: #!/usr/bin/python

---Doc string: 
.. module:: setPath
   :synopsis: Sets the path such that e.g. from smodels.tools import toolBox works.
              correctly. Called as a script, the path is printed.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: def configure():

---Doc string: 
    Get the path name of this file, remove set_path.py, remove the last
    subdir.

    The remaining string should be the base path name.

    
---Code snippet:     base = os.path.dirname(os.path.realpath(inspect.getabsfile(configure)))
    pos = base.rfind("/theory")
    base = base[:pos + 1]
    sys.path.append(base)
    # sys.path.append(base[:-9])
    return base
configure()
if __name__ == "__main__":

---Doc string: 
    Called as a script, print out the path.

    
-----------File: tools/externalPythia8.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: externalPythia8
   :synopsis: Wrapper for pythia8.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: class ExternalPythia8(ExternalTool):

---Doc string: 
    An instance of this class represents the installation of pythia8.
    
    
---Code snippet:     def compile(self):

---Doc string: 
        Compile pythia_lhe.
        
        
---Code snippet:     def checkInstallation(self):

---Doc string: 
        Check if installation of tool is correct by looking for executable and
        running it.
        
        
-----------File: smodels/tests/testTx.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: testTx
   :synopsis: Tests with Tx slha input files.
    
.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>
    

---Code snippet:     def testT1(self):
        self.logger.info ( "T1" )

---Doc string:  test with the T1 slha input file 
-----------File: validation/plots_closure/plotExcludedTChiChipmSlepStau095.py
No doc strings
-----------File: smodels/tests/testPhysicsUnits.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: testPhysicsUnits
   :synopsis: Tests conversion of the physics units.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


-----------File: theory/analysis.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: theory.analysis
   :synopsis: Encapsulates all data types around one result of one analysis,
              i.e. the association with one plot and one 
              reference cross section result.
        
.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>
        

---Code snippet: class ULanalysis(object):

---Doc string: 
    Class to store upper limit-type analyses.
    
    Stores the conditions and the elements constrained by the analysis as well
    as basic analysis info.
    
    self.conditions -- List of condition strings
    
    self.constraint -- Constraint string
    
    self.elementsEff -- Dictionary with constrained elements as keys and
    efficiencies as values
    
    
---Code snippet:     def getEfficiencyFor(self, element):

---Doc string: 
        Get (simple) efficiency for element.
        
        Returns zero if element is not constrained by the analysis or the
        element multiplicative factor if it is.
        
        :returns: float -- zero, if element is not found
        
        
---Code snippet:     def getUpperLimitFor(self, mass):

---Doc string: 
        Get the experimental upper limit for a specific mass array.
        
        :param mass: mass vector for computing the upper limit
        :returns: experimental upper limit for cross-section times BR
        
        
---Code snippet: class SRanalysis(object):

---Doc string: 
    Class to store signal region-type of analyses with efficiency maps.
    
    Stores the basic analysis info and contains a method for obtaining the
    efficiency from the database.
    
    
---Code snippet:     def getEfficiencyFor(self, element):

---Doc string:  Get efficiency from a database (dummy for now).        
        
---Code snippet:     def getLimitFor(self):

---Doc string:  Get experimental limit for a cross-section in a specific signal region.
        (dummy for now)
        
        :returns: experimental upper limit for cross-section in the signal
                  region
        
        
-----------File: experiment/limitGetter.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: experiment.limitGetter
   :synopsis: Access the proper experimental limits to given analysis objects.

.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>
.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>
.. moduleauthor:: Ursula Laa <Ursula.Laa@assoc.oeaw.ac.at>


---Code snippet: def limit(analysis, addTheoryPredictions=[]):

---Doc string: 
    Get limit from an analysis object.

    :param addTheoryPredictions: list of theory predictions to add, e.g.,
                                 [ '7 TeV (NLL)', '7 TeV (LO)' ]
    :type addTheoryPredictions: [String]
    
---Code snippet: def getPlotLimit(inmass, analysis):

---Doc string: 
    Get upper limit on sigma*BR for a specific array of masses from plot.
    
    :param inmass: Array of masses in SModelS graph.
    :param analysis: experiment.analysis.ULanalysis.
    
    
-----------File: smodels/tools/setPath.py
---Code snippet: #!/usr/bin/python

---Doc string: 
.. module:: setPath
   :synopsis: Sets the path such that e.g. from smodels.tools import toolBox works.
              correctly. Called as a script, the path is printed.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: def configure():

---Doc string: 
    Get the path name of this file, remove set_path.py, remove the last
    subdir.

    The remaining string should be the base path name.

    
---Code snippet:     base = os.path.dirname(os.path.realpath(inspect.getabsfile(configure)))
    pos = base.rfind("/tools")
    base = base[:pos + 1]
    sys.path.append(base)
    # sys.path.append(base[:-9])
    return base
configure()
if __name__ == "__main__":

---Doc string: 
    Called as a script, print out the path.

    
-----------File: theory/clusterTools.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: theory.clusterTools
   :synopsis: Module holding the ElementCluster class and cluster methods used to combine similar elements according
   to the analysis.
        
.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>
        

---Code snippet: class ElementCluster(object):

---Doc string: 
    An instance of this class represents a cluster.
    
    This class is used to store the relevant information about a cluster of
    elements and to manipulate this information.
    
    
---Code snippet:     def getTotalXSec(self):

---Doc string: 
        Return the sum over the cross-sections of all elements belonging to
        the cluster.
        
        
---Code snippet:     def getAvgMass(self):

---Doc string: 
        Return the average mass of all elements belonging to the cluster.
        
        :returns: average mass
         
        
---Code snippet: class IndexCluster(object):

---Doc string: 
    An instance of this class represents a cluster storing element indices.
    
    This auxiliary class is used to store element indices and positions in
    upper limit space. It is used by the clustering algorithm.
    
    
---Code snippet:     def add(self, iels):

---Doc string: 
        Add an index or a list of indices to the list of indices and update
        the avgPosition value.
        
        
---Code snippet:     def remove(self, iels):

---Doc string: 
        Remove an index or a list of indices to the list of indices and
        update the avgPosition value.
        
        
---Code snippet:     def _getAvgPosition(self):

---Doc string: 
        Return the average position in upper limit space for all indices
        belonging to the cluster.
        
        
---Code snippet:     def _getDistanceTo(self, obj):

---Doc string: 
        Return the maximum distance between any elements belonging to the
        cluster and the object obj.
        
        obj can be a position in upper limit space or an element index.
        
        
---Code snippet:     def _getMaxInternalDist(self):

---Doc string: 
        Return the maximum distance between any pair of elements belonging
        to the cluster as well as the cluster center and any element.
        
        
---Code snippet: def groupAll(elements):

---Doc string: 
    Create a single cluster containing all the elements.
    
    
---Code snippet: def clusterElements(elements, analysis, maxDist):

---Doc string:  Cluster the original elements according to their mass distance.
    
    :returns: list of clusters; If keepMassInfo == True, saves the original
              masses and their cluster value in massDict.
    
    
---Code snippet: def _doCluster(elements, analysis, maxDist):

---Doc string: 
    Cluster algorithm to cluster elements.
    
    :returns: a list of ElementCluster objects containing the elements
    belonging to the cluster
    
    
---Code snippet:     # First build the element:mass, element:position in UL space
    # and element:maxWeight (in fb) dictionaries
    #(Combine elements with identical masses)
    massMap = {}
    posMap = {}
    weightMap = {}
    for iel, el in enumerate(elements):
        if not el.getMasses() in massMap.values():
            massMap[iel] = el.getMasses()
            posMap[iel] = massPosition(massMap[iel], analysis)
            weightMap[iel] = rmvunit(el.weight.getMaxXsec(),'fb')
        else:
            j = massMap.keys()[massMap.values().index(el.getMasses())] 
            weightMap[j] += rmvunit(el.weight.getMaxXsec(),'fb')
    # Start with maximal clusters
    clusterList = []
    for iel in posMap:
        indices = [iel]
        for jel in posMap:            
            if distance(posMap[iel], posMap[jel]) <= maxDist:
                indices.append(jel)        
        indexCluster = IndexCluster(massMap, posMap, weightMap, set(indices), analysis)
        clusterList.append(indexCluster)

---Doc string: Split the maximal clusters until all elements inside each cluster are
    less than maxDist apart from each other and the cluster average position
    is less than maxDist apart from all elements
---Code snippet:     finalClusters = []
    newClusters = True
    while newClusters:
        newClusters = []
        for indexCluster in clusterList:
            # cluster is good
            if indexCluster._getMaxInternalDist() < maxDist:
                if not indexCluster in finalClusters:
                    finalClusters.append(indexCluster)
                continue
            # Distance to cluster center (average)
            distAvg = indexCluster._getDistanceTo(indexCluster.avgPosition)

---Doc string: Loop over cluster elements and if element distance or cluster
            average distance falls outside the cluster, remove element
---Code snippet: def _getGoodElements(elements, analysis, maxDist):

---Doc string: 
    Get the list of good masses appearing elements according to the analysis
    distance.
    
    :returns: list of elements with good masses with their masses replaced by
    the branch average. A mass is good if the mass distance between the
    branches is less than maxDist and if the element mass (or mass avg) falls
    inside the upper limit plane.
    
    
-----------File: validation/database/2012/SUS12002/sms.py
No doc strings
-----------File: validation/plots_closure/AuxPlot.py
---Code snippet: def set_palette(gStyle,name="none", ncontours=999):

---Doc string: Set a color palette from a given RGB list
    stops, red, green and blue should all be lists of the same length
    see set_decent_colors for an example
---Code snippet: def getContours(gROOT,vals,hist,fit=None):

---Doc string: Get contour graphs from a histogram with contour values vals
-----------File: validation/plots_closure/plotExcludedTSlepSlep.py
No doc strings
-----------File: theory/lheDecomposer.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: theory.lheDecomposer
   :synopsis: Decomposition of LHE events and creation of TopologyLists 

.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>


---Code snippet: def decompose(lhefile, inputXsecs=None, nevts=None, doCompress=False,
              doInvisible=False, minmassgap=None):

---Doc string: 
    Perform LHE-based decomposition. 

    :param lhefile: LHE file with e.g. pythia events
    :param inputXsecs: xSectionList object with cross-sections for the mothers
           appearing in the LHE file. If None, use information from file.
    :param nevts: (maximum) number of events used in the decomposition. If
                  None, all events from file are processed.
    :param doCompress: mass compression option (True/False)
    :param doInvisible: invisible compression option (True/False)
    :param minmassgap: minimum mass gap for mass compression (only used if
                       doCompress=True)
    :returns: TopologyList object 
    
    
---Code snippet: def elementFromEvent(event, weight=None):

---Doc string: 
    Creates an element from a LHE event and the corresponding event weight.
    
    :param event: LHE event
    :param weight: event weight. Must be a XSectionList object (usually with a
                   single entry) or None if not specified.
    :returns: element
    
    
---Code snippet: def _getDictionariesFromEvent(event):

---Doc string: 
    Create mass and BR dictionaries for each branch in an event.
    
    :param event: LHE event
    :returns: BR and mass dictionaries for the branches in the event
    
    
-----------File: smodels/tests/testTimeout.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: testTimeout
   :synopsis: checks if the timeout of pythia6 works
    
.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>
    

-----------File: tools/externalTool.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: externalTool
   :synopsis: Wrapper code for external tools: base class

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: class ExternalTool(object):

---Doc string: 
    An instance of this class represents the installation of an external tool.
    
    An external tool encapsulates a tool that is executed via
    commands.getoutput. It defines how the tool is tested for proper
    installation and how the tool is executed.
    
    
---Code snippet:     def installDirectory(self):

---Doc string: 
        TODO: write docstring
        
        
---Code snippet:     def pathOfExecutable(self):

---Doc string: 
        :returns: path of executable
        
        
---Code snippet:     def basePath(self):

---Doc string: 
        Get the base installation path.
        
        
---Code snippet:     def absPath(self, path):

---Doc string: 
        Get the absolute path of <path>, replacing <install> with the
        installation directory.
        
        
---Code snippet:     def ok(self,B):

---Doc string: 
        return 'ok', B is True. Else, return 'error'
        
        
-----------File: smodels/__init__.py
No doc strings
-----------File: tools/ioObjects.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
    .. module:: ioObjects
    :synopsis: Definitions of input/output parameters which are read from parameter.in
    
    .. moduleauthor:: Ursula Laa <Ursula.Laa@assoc.oeaw.ac.at>    
    .. moduleauthor:: Suchita Kulkarni <suchita.kulkarni@gmail.com>

---Code snippet: class ExptResults:

---Doc string: 
    A class to store all relevant information for one result
    
---Code snippet: class ResultList(Printer):

---Doc string: 
    Class that collects ExptResults objects and has a predefined printout
    
---Code snippet:     def formatData(self):

---Doc string: 
        to access printout format
        
---Code snippet: class OutputStatus(Printer):

---Doc string: 
    Object that holds all status information and has a predefined printout 
    
---Code snippet:     def formatData(self):

---Doc string: 
        to access printout format
        
---Code snippet: class MissingTopo():

---Doc string: 
    Object to describe one missing topology result
    
---Code snippet: class MissingTopoList(Printer):

---Doc string: 
    Object to find and collect MissingTopo objects, plus printout functionality
    
-----------File: smodels/setup.py
---Code snippet: def dataFiles ():

---Doc string:  obtain all data files dynamically 
-----------File: smodels/validation/plots_closure/AuxPlot.py
---Code snippet: def set_palette(gStyle,name="none", ncontours=999):

---Doc string: Set a color palette from a given RGB list
    stops, red, green and blue should all be lists of the same length
    see set_decent_colors for an example
---Code snippet: def getContours(gROOT,vals,hist,fit=None):

---Doc string: Get contour graphs from a histogram with contour values vals
-----------File: smodels/tools/MSSM_qNumbers.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: MSSM_qNumbers
   :synopsis: The quantum numbers of particles in the MSSM

.. moduleauthor:: Ursula Laa <Ursula.Laa@assoc.oeaw.ac.at>


-----------File: smodels/tests/setPath.py
---Code snippet: #!/usr/bin/python

---Doc string:                                                                                    
.. module:: setPath
   :synopsis: Sets the path such that e.g. "from tools import rootTools" works
   correctly. Called as a script, the path is printed.
                                                                                      
.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>             
                                                                                      

---Code snippet: def configure():

---Doc string: 
    Get the path name of this file, remove set_path.py, remove the last
    subdir.
    
    The remaining string should be the base path name.
    
    
---Code snippet:     base = os.path.dirname(os.path.realpath(inspect.getabsfile(configure)))
    pos = base.rfind("/")
    base = base[:pos + 1]
    sys.path.append(base)
    # sys.path.append(base[:-9])
    return base
configure()
if __name__ == "__main__":

---Doc string: 
    Called as a script, print out the path.
    
    
-----------File: smodels/validation/plots_closure/plotExcludedTChiWZ.py
No doc strings
-----------File: smodels/theory/analysis.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: theory.analysis
   :synopsis: Encapsulates all data types around one result of one analysis,
              i.e. the association with one plot and one 
              reference cross section result.
        
.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>
        

---Code snippet: class ULanalysis(object):

---Doc string: 
    Class to store upper limit-type analyses.
    
    Stores the conditions and the elements constrained by the analysis as well
    as basic analysis info.
    
    self.conditions -- List of condition strings
    
    self.constraint -- Constraint string
    
    self.elementsEff -- Dictionary with constrained elements as keys and
    efficiencies as values
    
    
---Code snippet:     def getEfficiencyFor(self, element):

---Doc string: 
        Get (simple) efficiency for element.
        
        Returns zero if element is not constrained by the analysis or the
        element multiplicative factor if it is.
        
        :returns: float -- zero, if element is not found
        
        
---Code snippet:     def getUpperLimitFor(self, mass):

---Doc string: 
        Get the experimental upper limit for a specific mass array.
        
        :param mass: mass vector for computing the upper limit
        :returns: experimental upper limit for cross-section times BR
        
        
---Code snippet: class SRanalysis(object):

---Doc string: 
    Class to store signal region-type of analyses with efficiency maps.
    
    Stores the basic analysis info and contains a method for obtaining the
    efficiency from the database.
    
    
---Code snippet:     def getEfficiencyFor(self, element):

---Doc string:  Get efficiency from a database (dummy for now).        
        
---Code snippet:     def getLimitFor(self):

---Doc string:  Get experimental limit for a cross-section in a specific signal region.
        (dummy for now)
        
        :returns: experimental upper limit for cross-section in the signal
                  region
        
        
-----------File: tests/testIntegration.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: testIntegration
   :synopsis: Integration test, tests a simple but complete use case.
              Uses the database in smodels/validation/database.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


-----------File: smodels/tests/testXSecComputer.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: testXSecComputer
   :synopsis: Compares the output of XSecComputer with a given value.
    
.. moduleauthor:: Wolfgang Magerl <wolfgang.magerl@gmail.com>
.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>
    

---Code snippet:     def testLO(self):

---Doc string:  test the computation of LO cross section 
---Code snippet:     def testNLL (self):

---Doc string:  test the computation of NLL cross section 
-----------File: validation/plots_closure/plotExcludedT1tt.py
No doc strings
-----------File: smodels/theory/element.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: theory.element
   :synopsis: Module holding the Element class and its methods.
    
.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>
    

---Code snippet: class Element(Printer):

---Doc string: 
    An instance of this class represents an element.
    
    This class possesses a pair of branches and the element weight
    (cross-section * BR).
    
    
---Code snippet:     def __init__(self, info=None):
        self.branches = [Branch(), Branch()]
        self.weight = crossSection.XSectionList()
        self.motherElements = []

---Doc string:  Elements that arise from compression have mother elements.
            Mother elements are pairs of ( whence, element ),
            'whence' describing what the element is from 
            (mass compression, invisible compression, etc),
            while 'element' is the actual object.
            If element is not due to compression, 
            then list remains empty.
        
---Code snippet:     def combineMotherElements ( self, el2 ):

---Doc string:  combine mother elements from self and el2 into self 
---Code snippet:     def __str__(self):

---Doc string: 
        Create the canonical name of the element, e.g. [[jet],[jet]].
        
        
---Code snippet:     def isEqual(self, other, order=False, useDict=True):

---Doc string: 
        Compare two Elements for equality.
        
        If order == False, test both branch orderings (for an element doublet
        only). If useDict == True, allow for nclusive particle labels.
        
        :returns: True, if all masses and particles are equal; False, else;        
        
        
---Code snippet:     def particlesMatch(self, other, order=False, useDict=True):

---Doc string: 
        Compare two Elements for matching particles.
        
        If order == False, test both branch orderings (for an element doublet
        only). If useDict == True, allow for inclusive particle abels.
        
        :returns: True, if particles match; False, else;
        
        
---Code snippet:     def copy(self):

---Doc string: 
        Create a copy of self.
        
        Faster than deepcopy.
        
        
---Code snippet:     def setMasses(self, mass, sameOrder=True, opposOrder=False):

---Doc string: 
        Set the element masses to the input mass array.
        
        If sameOrder == True, set the masses to the same branch ordering. If
        opposOrder == True, set the masses to the opposite branch ordering. If
        both sameOrder == True and opposOrder == True, set the masses to the
        smaller of the two orderings.
        
        
---Code snippet:     def switchBranches(self):

---Doc string: 
        Switch branches, if the element contains a pair of them.
                
        
---Code snippet:     def getParticles(self):

---Doc string: 
        Get the array of particles in the element.   
             
        
---Code snippet:     def getMasses(self):

---Doc string: 
        Get the array of masses in the element.   
             
        
---Code snippet:     def getDaughters(self):

---Doc string: 
        Get a pair of daughter IDs.
        
        Can be None, if the element does not have a definite daughter.      
           
        
---Code snippet:     def getMothers(self):

---Doc string: 
        Get a pair of mother IDs.
        
        Can be None, if the element does not have a mother daughter.
        
        
---Code snippet:     def getEinfo(self):

---Doc string: 
        Get global topology info from particle string.
        
        
---Code snippet:     def _getLength(self):

---Doc string: 
        Get the maximum of the two branch lengths.
        
        
---Code snippet:     def isInList(self, listOfElements, igmass=False, useDict=True):

---Doc string: 
        Check if the element is present in the element list.
        
        If igmass == False also check if the analysis has the element mass
        array.
        
        
---Code snippet:     def checkConsistency(self):

---Doc string: 
        Check if the particles defined in the element exist and are consistent
        with the element info.
        
        
---Code snippet:     def compressElement(self, doCompress, doInvisible, minmassgap):

---Doc string: 
        Keep compressing they original element and the derived ones till they
        can be compressed no more.
        
        :returns: list with the compressed elements
        
        
---Code snippet:     def massCompress(self, mingap):

---Doc string: 
        Perform mass compression.
        
        :returns: compressed copy of the element, if two masses in this
                  topology are degenerate; None, if compression is not possible;
        
        
---Code snippet:     def hasTopInList(self, elementList):

---Doc string: 
        Check if the element topology matches any of the topologies in the
        element list.
        
        
---Code snippet:     def invisibleCompress(self):

---Doc string: 
        Compress cascade decays ending with neutrinos and daughter.
        
        If no compression is possible, return None.
        
        
---Code snippet:     def formatData(self):

---Doc string: 
        Select data preparation method through dynamic binding.
        
---Code snippet: def _smallerMass(mass1, mass2):

---Doc string: 
    Select the smaller of two mass arrays.
    
    Use an ordering criterion (machine-independent) for selection.
    
    
-----------File: smodels/experiment/__init__.py
---Code snippet: NOT FOUND
---Doc string: 
This package is intended to contain everything that has to do with the
experimental results.


-----------File: theory/printer.py
---Code snippet: NOT FOUND
---Doc string: 
    .. module:: printer
       :synopsis: Facility used in classes to derive from and be able to print
                  different data types in different forms.

        .. moduleauthor:: Wolfgang Magerl <wolfgang.magerl@gmail.com>
        .. moduleauthor:: Ursula Laa <Ursula.Laa@assoc.oeaw.ac.at>    
        .. moduleauthor:: Suchita Kulkanri <suchita.kulkarni@gmail.com>

---Code snippet: class Printer(object):

---Doc string: 
    Printer class.
    
    
---Code snippet:     def printout(self, target="stdout", filename=""):

---Doc string: 
        Print the content of the data structure to the target.

        :param target: The target to print to. Possible values: stdout, file.
                       Default: stdout.
        :param filename: Filename to which the output is written
        :returns: None
        
        
---Code snippet:     def formatData(self):

---Doc string: 
        Format data of the derived object.
        
        Has to be implemented in the derived object. The real implementation is
        selected through dynamic binding.
        
        :raises: NotImplementedError  
              
        
---Code snippet:     def formatTopologyListData(self):
        from smodels.tools.physicsUnits import rmvunit

---Doc string: 
        Format data of to print Global topologies object.
        
---Code snippet:     def formatElementData(self):

---Doc string: 
            Format data of to print an element object.
        
---Code snippet:     def formatTheoryPredictionData(self):

---Doc string: 
        Format data of a TheoryPrediction object.
        
        
---Code snippet:     def formatStatusData(self):

---Doc string: 
        Format data of the output status object.
        
---Code snippet:     def formatResultsData(self):

---Doc string: 
        Format data of the final output object.
        
---Code snippet:     def formatSLHAData(self):

---Doc string: 
        Format data of the slha checks output object.
        
---Code snippet:     def formatMissingData(self):

---Doc string: 
        Format data of missing topology list.
        
-----------File: smodels/tests/testToolBox.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: testTx
   :synopsis: Tests with Tx slha input files.
    
.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>
    

-----------File: theory/lheReader.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: LheReader
   :synopsis: Provides a class that creates SMSEvents from LHE files.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: class LheReader(object):

---Doc string: 
    An instance of this class represents a reader for LHE files.
    
    
---Code snippet:     def __init__(self, filename, nmax=None):

---Doc string: 
        Constructor.
        
        :param filename: LHE file name
        :param nmax: When using the iterator, then nmax is the maximum number
        of events to be reader, nmax=None means read till the end of the file.
        If filename is not a string, assume it is already a file object and do
        not open it.
        
        
---Code snippet:     def next(self):

---Doc string: 
        Get next element in iteration.
        
        Needed for the iterator.
        
        
---Code snippet:     def __iter__(self):

---Doc string: 
        Make class iterable.
        
        Allows iterations like 'for a in lhereader: print a'.
        
        
---Code snippet:     def event(self):

---Doc string: 
        Get next event.
        
        :returns: SmsEvent; None if no event is left to be read.
        
        
---Code snippet:     def close(self):

---Doc string: 
        Close the lhe file, if open.
        
        
-----------File: tools/modpyslha.py
---Code snippet: #! /usr/bin/env python

---Doc string: \
A simple but flexible handler of the SUSY Les Houches Accord (SLHA) data format.

pyslha is a parser/writer module for particle physics SUSY Les Houches Accord
(SLHA) supersymmetric spectrum/decay files, and a collection of scripts which
use the interface, e.g. for conversion to and from the legacy ISAWIG format, or
to plot the mass spectrum and decay chains.

The current release supports SLHA version 1, and as far as I'm aware is also
fully compatible with SLHA2: the block structures are read and accessed
generically. If you have any problems, please provide an example input file and
I'll happily investigate. SLHA3 is not yet supported (or standardised) but in
recent releases the new structures will not crash the parser. Support will be
added once the format is standardised (and in response to demand!)

The plotting script provides output in PDF, EPS and PNG via LaTeX and the TikZ
graphics package, and as LaTeX/TikZ source for direct embedding into documents or
user-tweaking of the generated output.

Users of version 1.x should note that the interface has changed a little in
version 2.0.0 and onward, in particular in the interface of the Block objects,
which are now more dict-like: entries can be added and accessed via the usual
square-brackets indexing operators, including for multiple indices as is common
for mixing matrices e.g. NMIX[1,2] as opposed to the old NMIX.entries[1][2]
way. This does break backward compatibility but is a big improvement both for
internal code sanity and usability. The Block interface also now supplies
dict-like has_key(), keys(), and items() methods, as well as more specialist
value(), set_value() and is_single_valued() methods for improved access to ALPHA
and any other unindexed blocks.

If you use PySLHA, for either model data handling or spectrum visualisation,
please cite the paper: http://arxiv.org/abs/1305.4194

TODOs:

  For 3.0.x:
   * Add handling of XSECTION if/when standardised.
   * In set_value, if first item is non-int, treat as None-indexed.
   * Refine value string heuristic for strings with ints in them?
   * Use Doc to handle document-level header comments.
   * Add block and decay summary comments to the OrderedDict (wrap OrderedDict as DataStore?)

  For 3.1.x:
   * Preserve inline comments from read -> write (needs full-line/inline comment
     separation). Can use separate comment dicts in Block and Decay, and
     attach a multiline .comment attr to the returned/written dicts.

  Later/maybe:
   * Add Sphinx docs.
   * Identify HERWIG decay matrix element to use in ISAWIG.
   * Handle RPV SUSY in ISAWIG.

---Code snippet: def _mkdict():

---Doc string: Return an OrderedDict if possible, or a normal dict if not.
---Code snippet: class _dict(type(_d)):

---Doc string: A cosmetic wrapper on an OrderedDict if possible, or a normal dict if not.
---Code snippet: def _autotype(var):

---Doc string: Automatically convert strings to numerical types if possible.
---Code snippet: def _autostr(var, precision=8):

---Doc string: Automatically format numerical types as the right sort of string.
---Code snippet: def _autotuple(a):

---Doc string: Automatically convert the supplied iterable to a scalar or tuple as appropriate.
---Code snippet: def _read(f):

---Doc string: Read a file's contents, autodetecting whether the arg is a file or filename,
    and treating '-' as as indication to read from stdin.
---Code snippet: def _write(f, txt):

---Doc string: Write to a file, autodetecting whether the arg is a file or filename,
    and treating '-' as as indication to write to stdout.
---Code snippet:     def write(self, filename=None, ignorenobr=False, precision=8):

---Doc string: 
        Convenient method for converting an SLHA Doc object to SLHA format,
        either returned as a string or written to a file depending on whether
        the filename variable is None.
        
---Code snippet: class Block(object):

---Doc string: 
    Object representation of any BLOCK elements read from an SLHA file.

    Blocks have a name, may have an associated Q value, and contain a collection
    of data entries, each indexed by one or more keys. Entries in the dictionary
    are stored as numeric types (int or float) when a cast from the string in
    the file has been possible.

    Block is closely related to a Python dict (and, in fact, is implemented via
    an OrderedDict when possible). The preferred methods of entry access use the
    dict-like [] operator for getting and setting, and the keys() and items()
    methods for iteration. Purely iterating over the object behaves like keys(),
    as for an ordinary dict.

    Multiple (integer) indices are possible, especially for entries in mixing
    matrix blocks. These are now implemented in the natural way, e.g. for access
    to the (1,2) element of a mixing matrix block, use bmix[1,2] = 0.123 and
    print bmix[1,2]. The value() and set_value() functions behave
    similarly. Multi-element values are also permitted.

    It is possible, although not usual, to store unindexed values in a
    block. This is only supported when that entry is the only one in the block,
    and it is stored in the normal fashion but with None as the lookup key. The
    value() method may be used without a key argument to retrieve this value, if
    the is_single_valued() method returns True, and similarly the set_value()
    method may be used to set it if only one argument is supplied and the object
    is compatible.
    
---Code snippet:     def add_entry(self, args):

---Doc string: Add an entry to the block from an iterable (i.e. list or tuple) of
        strings, or from a whitespace-separated string.

        This method is just for convenience: it splits the single string
        argument if necessary and converts the list of strings into numeric
        types when possible. For the treatment of the resulting iterable see the
        set_value method.
        
---Code snippet:     def is_single_valued(self):

---Doc string: Return true if there is only one entry, and it has no index: the
        'value()' attribute may be used in that case without an argument.
---Code snippet:     def value(self, key=None, default=1):

---Doc string: Get a value from the block with the supplied key.

        If no key is given, then the block must contain only one non-indexed
        value otherwise an AccessError exception will be raised.\
        
---Code snippet:     def set_value(self, *args):

---Doc string: Set a value in the block via supplied key/value arguments.

        Indexing is determined automatically: any leading integers will be
        treated as a multi-dimensional index, with the remaining entries being a
        (potentially multi-dimensional) value. If all N args are ints, then the
        first N-1 are treated as the index and the Nth as the value.

        If there is only one arg it will be treated as the value of a
        single-valued block. In this case the block must already contain at most
        one non-indexed value otherwise an AccessError exception will be
        raised.\
        
---Code snippet:     def has_key(self, key):

---Doc string: Does the block have the given key?
---Code snippet:     def keys(self):

---Doc string: Access the block item keys.
---Code snippet:     def values(self):

---Doc string: Access the block item values.
---Code snippet:     def items(self, key=None):

---Doc string: Access the block items as (key,value) tuples.

        Note: The Python 3 dict attribute 'items()' is used rather than the
        'old' Python 2 'iteritems()' name for forward-looking compatibility.\
        
---Code snippet: class Decay(object):

---Doc string: 
    Object representing a decay entry on a particle decribed by the SLHA file.
    'Decay' objects are not a direct representation of a DECAY block in an SLHA
    file... that role, somewhat confusingly, is taken by the Particle class.

    Decay objects have three properties: a branching ratio, br, an nda number
    (number of daughters == len(ids)), and a tuple of PDG PIDs to which the
    decay occurs. The PDG ID of the particle whose decay this represents may
    also be stored, but this is normally known via the Particle in which the
    decay is stored.
    
---Code snippet: class Particle(object):

---Doc string: 
    Representation of a single, specific particle, decay block from an SLHA
    file.  These objects are not themselves called 'Decay', since that concept
    applies more naturally to the various decays found inside this
    object. Particle classes store the PDG ID (pid) of the particle being
    represented, and optionally the mass (mass) and total decay width
    (totalwidth) of that particle in the SLHA scenario. Masses may also be found
    via the MASS block, from which the Particle.mass property is filled, if at
    all. They also store a list of Decay objects (decays) which are probably the
    item of most interest.
    
---Code snippet: def readSLHA(spcstr, ignorenobr=False, ignorenomass=False, ignoreblocks=[]):

---Doc string: 
    Read an SLHA definition from a string, returning dictionaries of blocks and
    decays.

    If the ignorenobr parameter is True, do not store decay entries with a
    branching ratio of zero.

    If the ignorenomass parameter is True, parse file even if mass block is
    absent in the file (default is to raise a ParseError).
    
---Code snippet: def writeSLHABlocks(blocks, precision=8):

---Doc string: Return an SLHA definition as a string, from the supplied blocks dict.
---Code snippet: def writeSLHADecays(decays, ignorenobr=False, precision=8):

---Doc string: Return an SLHA decay definition as a string, from the supplied decays dict.
---Code snippet: def writeSLHA(doc, ignorenobr=False, precision=8):

---Doc string: Return an SLHA definition as a string, from the supplied blocks and decays dicts.
---Code snippet: def herwigid2pdgid(hwid):

---Doc string: 
    Convert a particle ID code in the HERWIG internal IDHW format (as used by
    ISAWIG) into its equivalent in the standard PDG ID code definition.
    
---Code snippet: def pdgid2herwigid(pdgid):

---Doc string: 
    Convert a particle ID code in the standard PDG ID code definition into
    its equivalent in the HERWIG internal IDHW format (as used by ISAWIG).
    
---Code snippet: def readISAWIG(isastr, ignorenobr=False):

---Doc string: 
    Read a spectrum definition from a string in the ISAWIG format, returning
    dictionaries of blocks and decays. While this is not an SLHA format, it is
    informally supported as a useful mechanism for converting ISAWIG spectra to
    SLHA.

    ISAWIG parsing based on the HERWIG SUSY specification format, from
    http://www.hep.phy.cam.ac.uk/~richardn/HERWIG/ISAWIG/file.html

    If the ignorenobr parameter is True, do not store decay entries with a
    branching ratio of zero.
    
---Code snippet: def writeISAWIG(doc, ignorenobr=False, precision=8):

---Doc string: 
    Return a SUSY spectrum definition in the format produced by ISAWIG for inut to HERWIG
    as a string, from the supplied SLHA blocks and decays dicts.

    ISAWIG parsing based on the HERWIG SUSY specification format, from
    http://www.hep.phy.cam.ac.uk/~richardn/HERWIG/ISAWIG/file.html

    If the ignorenobr parameter is True, do not write decay entries with a
    branching ratio of zero.
    
---Code snippet:                 def cmp_bottomlast(a, b):

---Doc string: Comparison function which always puts b/bbar last
---Code snippet:                         def cmp_gluonfirst(a, b):

---Doc string: Comparison function which always puts gluon first
---Code snippet:                     def cmp_quarkslast(a, b):

---Doc string: Comparison function which always puts quarks last
---Code snippet:                     def cmp_quarkslast(a, b):

---Doc string: Comparison function which always puts quarks last
---Code snippet:                     def cmp_quarkslast(a, b):

---Doc string: Comparison function which always puts quarks last
---Code snippet: def read(spcfile, **kwargs):

---Doc string: 
    Read an SLHA or ISAWIG file (or stdin).

    spcfile may either be a string filename or a file object.
    If a s string, the assumed file format is based from the
    filename; if a file it is assumed to be SLHA format.

    Other keyword parameters are passed to readSLHA/readISAWIG.
    
---Code snippet: def readSLHAFile(spcfile, **kwargs):

---Doc string: 
    Read an SLHA file, returning dictionaries of blocks and decays.

    Other keyword parameters are passed to readSLHA.
    
---Code snippet: def readISAWIGFile(isafile, **kwargs):

---Doc string: 
    Read a spectrum definition from a file in the ISAWIG format, returning
    dictionaries of blocks and decays. While this is not an SLHA format, it is
    informally supported as a useful mechanism for converting ISAWIG spectra to
    SLHA.

    isafile may either be a string filename or a file object.

    Other keyword parameters are passed to readISAWIG.
    
---Code snippet: def write(spcfile, doc, **kwargs):

---Doc string: 
    Write to an SLHA or ISAWIG file (or stdout).

    spcfile may either be a string filename or a file object.
    If a s string, the assumed file format is based from the
    filename; if a file it is assumed to be SLHA format.

    Other keyword parameters are passed to writeSLHA/writeISAWIG.
    
---Code snippet: def writeSLHAFile(spcfile, doc, **kwargs):

---Doc string: 
    Write an SLHA file from the supplied blocks and decays dicts.

    Other keyword parameters are passed to writeSLHA.
    
---Code snippet: def writeISAWIGFile(isafile, doc, **kwargs):

---Doc string: 
    Write an ISAWIG file from the supplied blocks and decays dicts.

    isafile may either be a string filename or a file object.

    Other keyword parameters are passed to writeISAWIG.
    
-----------File: validation/plots_closure/plotExcludedT2CMS.py
No doc strings
-----------File: smodels/experiment/smsHelpers.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: experiment.smsHelpers
   :synopsis: Contains private helper functions to access the SMS results.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>
.. moduleauthor:: Ursula Laa <Ursula.Laa@assoc.oeaw.ac.at>
.. moduleauthor:: Doris Proschofsky <Doris.Proschofsky@assoc.oeaw.ac.at>
.. moduleauthor:: Wolfgang Magerl <wolfgang.magerl@gmail.com>


---Code snippet: def getRun(analysis, run=None):

---Doc string: 
    Search for an analysis.

    If a specific run is given, check if results are present.

    :returns: run; None, if not found;

    
---Code snippet: def getLines(analysis, run, label="condition"):

---Doc string: 
    Get all <label> lines in info.txt for an analysis-run pair.

    
---Code snippet: def getMetaInfoField(analysis, field, run=None):

---Doc string: 
    Get one specific entry of the meta info.

    
---Code snippet: def _parseMetaInfo(analysis, run):

---Doc string: 
    Get all the meta information for a given analysis-run pair.

    
---Code snippet: def getUpperLimitDictionary(analysis, topology, run, expected=False):

---Doc string: 
    Returns a dictionary containing the raw Upper Limit data for the analysis
    and topology. 

    
---Code snippet: def hasDictionary(analysis, run=None, topology=None):

---Doc string: 
    Check if available upper limits are in dictionary format.

    
---Code snippet: def databaseVersion(astuple=False):

---Doc string:  prints out version number of the *database* 
-----------File: smodels/setPath.py
---Code snippet: #!/usr/bin/env python

---Doc string:                                                                                    
.. module:: setPath
   :synopsis: Sets the path such that e.g. "from smodels.tools import toolBox" works
   correctly. Called as a script, the path is printed.
                                                                                      
.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>             
                                                                                      

---Code snippet: def configure():

---Doc string: 
    Get the path name of this file, remove setPath.py, remove the last
    subdir.
    
    The remaining string should be the base path name.
    
    
---Code snippet:     base = os.path.dirname(os.path.realpath(inspect.getabsfile(configure)))
    pos = base.rfind("/")
    # base = base[:pos + 1]
    sys.path.append(base)
    # sys.path.append(base[:-9])
    return base
configure()
if __name__ == "__main__":

---Doc string: 
    Called as a script, print out the path.
    
    
-----------File: theory/theoryPrediction.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: theory.theoryPrediction
   :synopsis: Provides a class to encapsulate the results of the computation of
              reference cross sections and related functions.
        
.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>
        

---Code snippet: class TheoryPrediction(object):

---Doc string: 
    An instance of this class represents the results of the theory prediction
    for an analysis.
    
    
---Code snippet: class TheoryPredictionList(Printer):

---Doc string: 
    An instance of this class represents the a collection of theory prediction
    objects.
    
    
---Code snippet:     def formatData(self):

---Doc string: 
        Select data preparation method through dynamic binding.
        
        
---Code snippet: def theoryPredictionFor(analysis, smsTopList, maxMassDist=0.2):

---Doc string: 
    Compute theory predictions.
    
    Collect elements and efficiencies, combine the masses (if needed) and
    compute the conditions (if existing).
    
    :returns: list of TheoryPrediction objects
    
    
---Code snippet: def _getElementsFrom(smsTopList, analysis):

---Doc string: 
    Get elements, that are constrained by the analysis.
    
    Loop over all elements in smsTopList and returns the elements which are
    constrained by the analysis (have efficiency != 0). The elements weights
    are multiplied by their respective efficiency and the cross-sections not
    matching the analysis sqrts are removed.
    
    
---Code snippet: def _combineElements(elements, analysis, maxDist):

---Doc string: 
    Combine elements according to the analysis type.
    
    If analysis == upper limit type, group elements into mass clusters. If
    analysis == signal region type, group all elements into a single cluster.
    
    
---Code snippet: def _evalConstraint(cluster, analysis):

---Doc string: 
    Evaluate the analysis constraint inside an element cluster.
    
    If analysis type == upper limit, evaluates the analysis constraint inside
    an element cluster.
    
    :retunrs: total cluster cross-section, if analysis type == signal region
    
    
---Code snippet: def _evalConditions(cluster, analysis):

---Doc string: 
    Evaluate the analysis conditions inside an element cluster.
    
    If analysis type == upper limit, evaluates the analysis conditions inside
    an element cluster.
    
    :retunrs: None, if analysis type == signal region
    
    
---Code snippet: def _evalExpression(stringExpr,cluster,analysis):

---Doc string: 
    Auxiliary method to evaluate a string expression using the weights of the elements in the cluster.
    
    :return: cross-section value for the expression or expression value if it is not numerical (None,string,...)
    
-----------File: theory/particleNames.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: ParticleNames
   :synopsis: Provides functions for getting particle names from pdg ids, and
              other helpers.

.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>


---Code snippet: def getName(pdg):

---Doc string: 
    Convert pdg number to particle name according to the dictionaries rOdd and
    rEven.

    :type pdg: int
    :returns: particle name (e.g. gluino, mu-, ...)
    
    
---Code snippet: def getPdg(name):

---Doc string: 
    Convert a name to the pdg number according to the dictionaries rOdd and
    rEven.

    :type name: string
    :returns: particle pdg; None, if name could not be resolved
    
    
---Code snippet: def elementsInStr(instring):

---Doc string: 
    Parse instring and return a list of elements appearing in instring.
    
    instring can also be a list of strings.
    
    :returns: list of elements appearing in instring in string format
    
    
---Code snippet: def vertInStr(instring):

---Doc string: 
    Parses instring (or a list of strings) and returns the list of particle
    vertices appearing in instring.
    
    
---Code snippet: def simParticles(ptype1, ptype2, useDict=True):

---Doc string: 
    Compares 2 particle names or 2 nested name arrays. Allows for dictionary
    labels (Ex: L = l, l+ = l, l = l-,...). For the last nested level ignore
    particle ordering. FIXME nesting? 
 
    :param ptype1: first (nested) list of particle names, e.g. ['l','jet']
    :param ptype2: second (nested) list of particle names 
    :param useDict: use the translation dictionary, i.e. allow e to stand for
                    e+ or e-, l+ to stand for e+ or mu+, etc 
    :returns: boolean
    
    
-----------File: validation/plots_closure/plotExcluded2.py
No doc strings
-----------File: experiment/setPath.py
---Code snippet: #!/usr/bin/python

---Doc string: 
.. module:: setPath
   :synopsis: Sets the path such that e.g. from smodels.tools import toolBox works.
              correctly. Called as a script, the path is printed.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: def configure():

---Doc string: 
    Get the path name of this file, remove set_path.py, remove the last
    subdir.

    The remaining string should be the base path name.

    
---Code snippet:     base = os.path.dirname(os.path.realpath(inspect.getabsfile(configure)))
    pos = base.rfind("/experiment")
    base = base[:pos + 1]
    sys.path.append(base)
    # sys.path.append(base[:-9])
    return base
configure()
if __name__ == "__main__":

---Doc string: 
    Called as a script, print out the path.

    
-----------File: tests/testPhysicsUnits.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: testPhysicsUnits
   :synopsis: Tests conversion of the physics units.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


-----------File: theory/slhaDecomposer.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: theory.slhaDecomposer
   :synopsis: Decomposition of SLHA events and creation of TopologyLists.
        
.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>
        

---Code snippet: def decompose(slhafile, sigcut=0.1, doCompress=False, doInvisible=False,
              minmassgap=-1, useXSecs=None):

---Doc string: 
    Perform SLHA-based decomposition.
    
    :param slhafile: file with mass spectrum and branching ratios and
                     optionally with cross-sections
    :param Xsec: optionally a dictionary with cross-sections for pair
                 production, by default reading the cross sections 
                 from the SLHA file.
    :param XsecsInfo: information about the cross-sections (sqrts, order and
           label). Only relevant for Xsec=None (reading from slha file). If defined 
           as input or in crossSection.XSectionInfo restricts the 
           cross-sections values in the SLHA file to the ones in XsecsInfo. 
           If not defined, it will be generated from the SLHA file and stored in 
           crossSection.XSectionInfo. Only generated if cross-sections are read 
           from SLHA file and not previously created
    :param sigcut: minimum sigma*BR to be generated, by default sigcut = 0.1 fb
    :param doCompress: turn mass compressed topologies on/off
    :param doInvisible: turn invisibly compressed topologies on/off
    :param minmassgap: maximum value for considering two R-odd particles
                       degenerate (only revelant for doCompress=True)        
    :returns: TopologyList
     
    
---Code snippet: def _getDictionariesFromSLHA(slhafile):

---Doc string: 
    Create mass and BR dictionaries from an SLHA file.
    Ignore decay blocks with R-parity violating or unknown decays
    
    
-----------File: validation/plots_closure/plotExcludedT5WW050.py
No doc strings
-----------File: smodels/experiment/smsResults.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: experiment.smsResults
   :synopsis: Centralized facility to access the SMS results.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>
.. moduleauthor:: Ursula Laa <Ursula.Laa@assoc.oeaw.ac.at>
.. moduleauthor:: Doris Proschofsky <Doris.Proschofsky@assoc.oeaw.ac.at>
.. moduleauthor:: Wolfgang Magerl <wolfgang.magerl@gmail.com>


---Code snippet: def getAllResults(run=None):

---Doc string: 
    Get all analyses and topologies that have results.

    
---Code snippet: def getTopologies(analysis, run=None):

---Doc string: 
    Get all topologies of an analysis with constraints.

    
---Code snippet: def getConstraints(analysis, topology="all", run=None):

---Doc string: 
    Get constraints of an analysis.

    :returns: dictionary of constraints, if topology == "all"; single
              constraint for the passed topology, if only one topology is passed; 
              None if non-existent;

    
---Code snippet: def getSqrts(analysis, run=None):

---Doc string:  get the center-of-mass energy of the analysis.
    
---Code snippet: def getConditions(analysis, topology="all", fuzzy=True, run=None):

---Doc string: 
    Get conditions of an analysis.

    :returns: dictionary of conditions, if topology == "all"; single condition
              for the passed topology, if only one topology is passed; None if
              non-existent.

    
---Code snippet: def getaxes(analysis, topology=None, run=None):

---Doc string: Get information about the histogram axes for an analysis.

    For each topology list of dictionary, each dictionary corresponds to one
    histogram. The key axes gives string (mx-my), the key mz gives information
    on other masses, if you supply a topology, returns list for this topology
    only.

    
---Code snippet: def setBase(base):

---Doc string: 
    Set the base directory of the database.
    
    
---Code snippet: def getBase():

---Doc string: 
    Return the base directory of the database.
    
    
---Code snippet: def getURL(analysis, run=None):

---Doc string: 
    Get the URL of an analysis.
    
    
---Code snippet: def hasURL(analysis, run=None):

---Doc string: 
    Check if URL of an analysis exists.
---Code snippet: def getPAS(analysis, run=None):

---Doc string: 
    Get the PAS of an analysis.
    
    
---Code snippet: def getJournal(analysis, run=None):

---Doc string: 
    Get the journal of an analysis.
    
    
---Code snippet: def getLumi(analysis, run=None):

---Doc string: 
    Get the integrated luminosity for an analysis.
    
    
---Code snippet: def isPrivate(analysis, run=None):

---Doc string: 
    Check if analysis is flagged as private.
    
---Code snippet: def getExperiment(analysis, run=None):

---Doc string: 
    Check if run is ATLAS8TeV, else return CMS.
    
    
---Code snippet: def getComment(analysis, run=None):

---Doc string: 
    Get the comment of an analysis.
    
    
---Code snippet: def considerRuns(runs):

---Doc string: 
    Define the run labels to be considered.
    
    
---Code snippet: def _exists(analysis, topology, run=None):

---Doc string: 
    Check if the dictionary 'limit_topo' in <run>/<analysis>/sms.py exists.

    For topologies with intermediate masses, check if all dictionaries listed
    in the axes-information exist. If topology == None, check if
    <run>/<analysis>/sms.py exists.

    
---Code snippet: def getUpperLimit(analysis, topology, mx=None, my=None, run=None,
                  interpolate=False, expected=False):

---Doc string: 
    Get the upper limit for run/analysis/topology.

    :returns: None, if it does not exist; entire dictionary, if mx and my are
              None; upper limit at mx/my, if mx and my are floats;

    
---Code snippet: def getUpperLimitFromDictionary(analysis, topology, mx=None, my=None,
                                run=None, png=None, interpolate=False,
                                expected=False):

---Doc string: 
    Get an upper limit from the python dictionary.

    
---Code snippet: def getInterpolatedUpperLimitDelaunay(dictionary, inmx, inmy):

---Doc string: 
    Get interpolated upper limit from dictionary at point (inmx, inmy).

    :param dictionary: dictionary (sms.py), contains upper limits of one
                       analysis and one topology
    :param inmx: mass point on x-axis
    :param inmy: mass point on y-axis
    :returns: interpolated upper limit at point (inmx, inmy)

    
---Code snippet: def inConvexHull(dictionary, mx, my):

---Doc string: 
    Check if (mx,my) point is in the data dictionary.

    
---Code snippet: def getClosestValue(dictionary, mx, my):

---Doc string: 
    Get the upper limit of the point in dictionary that is closest to mx and
    my, assuming that dictionary is a dictionary of mx, my, ul.

    
-----------File: smodels/theory/theoryPrediction.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: theory.theoryPrediction
   :synopsis: Provides a class to encapsulate the results of the computation of
              reference cross sections and related functions.
        
.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>
        

---Code snippet: class TheoryPrediction(object):

---Doc string: 
    An instance of this class represents the results of the theory prediction
    for an analysis.
    
    
---Code snippet: class TheoryPredictionList(Printer):

---Doc string: 
    An instance of this class represents the a collection of theory prediction
    objects.
    
    
---Code snippet:     def formatData(self):

---Doc string: 
        Select data preparation method through dynamic binding.
        
        
---Code snippet: def theoryPredictionFor(analysis, smsTopList, maxMassDist=0.2):

---Doc string: 
    Compute theory predictions.
    
    Collect elements and efficiencies, combine the masses (if needed) and
    compute the conditions (if existing).
    
    :returns: list of TheoryPrediction objects
    
    
---Code snippet: def _getElementsFrom(smsTopList, analysis):

---Doc string: 
    Get elements, that are constrained by the analysis.
    
    Loop over all elements in smsTopList and returns the elements which are
    constrained by the analysis (have efficiency != 0). The elements weights
    are multiplied by their respective efficiency and the cross-sections not
    matching the analysis sqrts are removed.
    
    
---Code snippet: def _combineElements(elements, analysis, maxDist):

---Doc string: 
    Combine elements according to the analysis type.
    
    If analysis == upper limit type, group elements into mass clusters. If
    analysis == signal region type, group all elements into a single cluster.
    
    
---Code snippet: def _evalConstraint(cluster, analysis):

---Doc string: 
    Evaluate the analysis constraint inside an element cluster.
    
    If analysis type == upper limit, evaluates the analysis constraint inside
    an element cluster.
    
    :retunrs: total cluster cross-section, if analysis type == signal region
    
    
---Code snippet: def _evalConditions(cluster, analysis):

---Doc string: 
    Evaluate the analysis conditions inside an element cluster.
    
    If analysis type == upper limit, evaluates the analysis conditions inside
    an element cluster.
    
    :retunrs: None, if analysis type == signal region
    
    
---Code snippet: def _evalExpression(stringExpr,cluster,analysis):

---Doc string: 
    Auxiliary method to evaluate a string expression using the weights of the elements in the cluster.
    
    :return: cross-section value for the expression or expression value if it is not numerical (None,string,...)
    
-----------File: smodels/theory/lheDecomposer.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: theory.lheDecomposer
   :synopsis: Decomposition of LHE events and creation of TopologyLists 

.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>


---Code snippet: def decompose(lhefile, inputXsecs=None, nevts=None, doCompress=False,
              doInvisible=False, minmassgap=None):

---Doc string: 
    Perform LHE-based decomposition. 

    :param lhefile: LHE file with e.g. pythia events
    :param inputXsecs: xSectionList object with cross-sections for the mothers
           appearing in the LHE file. If None, use information from file.
    :param nevts: (maximum) number of events used in the decomposition. If
                  None, all events from file are processed.
    :param doCompress: mass compression option (True/False)
    :param doInvisible: invisible compression option (True/False)
    :param minmassgap: minimum mass gap for mass compression (only used if
                       doCompress=True)
    :returns: TopologyList object 
    
    
---Code snippet: def elementFromEvent(event, weight=None):

---Doc string: 
    Creates an element from a LHE event and the corresponding event weight.
    
    :param event: LHE event
    :param weight: event weight. Must be a XSectionList object (usually with a
                   single entry) or None if not specified.
    :returns: element
    
    
---Code snippet: def _getDictionariesFromEvent(event):

---Doc string: 
    Create mass and BR dictionaries for each branch in an event.
    
    :param event: LHE event
    :returns: BR and mass dictionaries for the branches in the event
    
    
-----------File: tools/physicsUnits.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: physicsUnits
   :synopsis: This introduces physical units (GeV, fb) to the framework.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: def addunit(value, unitstring):

---Doc string: 
    Add units to values.
    
    Allow to turn this functionality off, in case "units" is not installed.
    
    
---Code snippet: def rmvunit(value, unitstring):

---Doc string: 
    Remove units from values.
    
    Allow to turn this functionality off, in case "units" is not installed.
    
    
---Code snippet:     if not useUnits:
        return value
    if useUnits:
        if type(value) != type(1.*GeV):
            return value
        if unitstring == "GeV":
            return value.asNumber(GeV)
        if unitstring == "TeV":
            return value.asNumber(TeV)
        if unitstring == "fb":
            return value.asNumber(fb)
        if unitstring == "pb":
            return value.asNumber(pb)
        if unitstring == "fb-1":
            return value.asNumber(1 / fb)
        logger.warning("Unknown unit: " + unitstring)
        return value
if __name__ == "__main__":

---Doc string: 
    Called as script, will print some physicsUnits.
    
    
-----------File: smodels/validation/database/2012/SUS12009/sms.py
No doc strings
-----------File: smodels/tools/callGraph.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: callGraph
   :synopsis: Call pycallgraph to create call graphs of simpleExample for
              different input files.
              Usage: has to be invoked in the SModelS root directory:
              >>> python -m tools.callGraph
              >>> python -m tools.callGraph --max-depth 3

.. moduleauthor:: Wolfgang Magerl <wolfgang.magerl@gmail.com>


---Code snippet: def main():

---Doc string: 
    Executes pycallgraph to create call graphs of simpleExample.
    
    
-----------File: theory/auxiliaryFunctions.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: theory.auxiliaryFunctions
   :synopsis: A collection of functions used to evaluate fuzzy the conditions.

.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>


---Code snippet: def _memoize(func):

---Doc string: 
    Cache the results of massPosition.
    
    Serves as a wrapper to cache the results of massPosition, since this is a
    computationally expensive function.
    
    
---Code snippet: def massPosition(mass, analysis):

---Doc string:  Give mass position in upper limit space.    
    Use the analysis experimental limit data.    
    
---Code snippet: def distance(xmass1, xmass2):

---Doc string: 
    Define distance between two mass positions.
    
    
---Code snippet: def massAvg(massList, method='weighted', weights=None):

---Doc string: 
    Compute the average mass of massList according to method.

    If method=weighted but weights were not properly defined,
    switch method to harmonic.    
    If massList contains a zero mass, switch method to mean.
    
    :param method: possible values: harmonic, mean, weighted
    :param weights: weights of elements (only for weighted average)
    
    
---Code snippet: def cSim(*weights):

---Doc string: 
    Define the auxiliar similar function.
    
    Return the maximum relative difference between any element weights of the
    list, normalized to [0,1].
    
    :returns: XSectionList object with the values for each label.
    
    
---Code snippet: def cGtr(weightA, weightB):

---Doc string: 
    Define the auxiliary greater function.
    
    Return a number between 0 and 1 depending on how much it is violated
    (0 = A > B, 1 = A << B).
    
    :returns: XSectioList object with the values for each label.
    
    
---Code snippet: def _flattenList(inlist, dims=None):

---Doc string: 
    Flatten a multi-dimensional nested list.
    
    Output ordering: [first level objects, second level objects, ...].    
    
    If dims == [], include dimensions of nested list to it. This is useful when
    comparing lists).
    
    
-----------File: tools/setPath.py
---Code snippet: #!/usr/bin/python

---Doc string: 
.. module:: setPath
   :synopsis: Sets the path such that e.g. from smodels.tools import toolBox works.
              correctly. Called as a script, the path is printed.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: def configure():

---Doc string: 
    Get the path name of this file, remove set_path.py, remove the last
    subdir.

    The remaining string should be the base path name.

    
---Code snippet:     base = os.path.dirname(os.path.realpath(inspect.getabsfile(configure)))
    pos = base.rfind("/tools")
    base = base[:pos + 1]
    sys.path.append(base)
    # sys.path.append(base[:-9])
    return base
configure()
if __name__ == "__main__":

---Doc string: 
    Called as a script, print out the path.

    
-----------File: smodels/tests/testCompression.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: testCompression
   :synopsis: Checks the compression algorithms
    
.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>
    

---Code snippet:     def testInvisiblePositive(self):

---Doc string:  test the invisible compression, a positive example 
---Code snippet:     def testInvisibleNegative(self):

---Doc string:  test the invisible compression, a negative example 
---Code snippet:     def testMass(self):

---Doc string:  test the mass compression, a positive and negative example 
-----------File: validation/plots_closure/lixo.py
No doc strings
-----------File: smodels/tools/smsPrettyPrinter.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: smsPrettyPrinter
   :synopsis: missing

.. moduleauthor:: missing <email@example.com>


---Code snippet: class SmsPrettyPrinter(PrettyPrinter):

---Doc string: 
    An instance of this class represents a printing facility."
    
    
---Code snippet:     def format(self, entity, context, maxlevels, level):

---Doc string: 
        TODO: write docstring
        
        
---Code snippet: def wrapOnspace(text, width):

---Doc string: 
    Preserves existing line breaks and most spaces in the text. Expects that
    existing line breaks are posix newlines (\\n).
    
    
---Code snippet: def wrapAlways(text, width):

---Doc string: 
    Wraps text on exactly width characters. It doesn't split the text in words.
    
    
---Code snippet: def wrap(text, width):

---Doc string: 
    Similar to wrapOnspace, but enforces the width constraint: words longer
    than width are split.
    
    
-----------File: smodels/experiment/setPath.py
---Code snippet: #!/usr/bin/python

---Doc string: 
.. module:: setPath
   :synopsis: Sets the path such that e.g. from smodels.tools import toolBox works.
              correctly. Called as a script, the path is printed.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: def configure():

---Doc string: 
    Get the path name of this file, remove set_path.py, remove the last
    subdir.

    The remaining string should be the base path name.

    
---Code snippet:     base = os.path.dirname(os.path.realpath(inspect.getabsfile(configure)))
    pos = base.rfind("/experiment")
    base = base[:pos + 1]
    sys.path.append(base)
    # sys.path.append(base[:-9])
    return base
configure()
if __name__ == "__main__":

---Doc string: 
    Called as a script, print out the path.

    
-----------File: smodels/tools/modpyslha.py
---Code snippet: #! /usr/bin/env python

---Doc string: \
A simple but flexible handler of the SUSY Les Houches Accord (SLHA) data format.

pyslha is a parser/writer module for particle physics SUSY Les Houches Accord
(SLHA) supersymmetric spectrum/decay files, and a collection of scripts which
use the interface, e.g. for conversion to and from the legacy ISAWIG format, or
to plot the mass spectrum and decay chains.

The current release supports SLHA version 1, and as far as I'm aware is also
fully compatible with SLHA2: the block structures are read and accessed
generically. If you have any problems, please provide an example input file and
I'll happily investigate. SLHA3 is not yet supported (or standardised) but in
recent releases the new structures will not crash the parser. Support will be
added once the format is standardised (and in response to demand!)

The plotting script provides output in PDF, EPS and PNG via LaTeX and the TikZ
graphics package, and as LaTeX/TikZ source for direct embedding into documents or
user-tweaking of the generated output.

Users of version 1.x should note that the interface has changed a little in
version 2.0.0 and onward, in particular in the interface of the Block objects,
which are now more dict-like: entries can be added and accessed via the usual
square-brackets indexing operators, including for multiple indices as is common
for mixing matrices e.g. NMIX[1,2] as opposed to the old NMIX.entries[1][2]
way. This does break backward compatibility but is a big improvement both for
internal code sanity and usability. The Block interface also now supplies
dict-like has_key(), keys(), and items() methods, as well as more specialist
value(), set_value() and is_single_valued() methods for improved access to ALPHA
and any other unindexed blocks.

If you use PySLHA, for either model data handling or spectrum visualisation,
please cite the paper: http://arxiv.org/abs/1305.4194

TODOs:

  For 3.0.x:
   * Add handling of XSECTION if/when standardised.
   * In set_value, if first item is non-int, treat as None-indexed.
   * Refine value string heuristic for strings with ints in them?
   * Use Doc to handle document-level header comments.
   * Add block and decay summary comments to the OrderedDict (wrap OrderedDict as DataStore?)

  For 3.1.x:
   * Preserve inline comments from read -> write (needs full-line/inline comment
     separation). Can use separate comment dicts in Block and Decay, and
     attach a multiline .comment attr to the returned/written dicts.

  Later/maybe:
   * Add Sphinx docs.
   * Identify HERWIG decay matrix element to use in ISAWIG.
   * Handle RPV SUSY in ISAWIG.

---Code snippet: def _mkdict():

---Doc string: Return an OrderedDict if possible, or a normal dict if not.
---Code snippet: class _dict(type(_d)):

---Doc string: A cosmetic wrapper on an OrderedDict if possible, or a normal dict if not.
---Code snippet: def _autotype(var):

---Doc string: Automatically convert strings to numerical types if possible.
---Code snippet: def _autostr(var, precision=8):

---Doc string: Automatically format numerical types as the right sort of string.
---Code snippet: def _autotuple(a):

---Doc string: Automatically convert the supplied iterable to a scalar or tuple as appropriate.
---Code snippet: def _read(f):

---Doc string: Read a file's contents, autodetecting whether the arg is a file or filename,
    and treating '-' as as indication to read from stdin.
---Code snippet: def _write(f, txt):

---Doc string: Write to a file, autodetecting whether the arg is a file or filename,
    and treating '-' as as indication to write to stdout.
---Code snippet:     def write(self, filename=None, ignorenobr=False, precision=8):

---Doc string: 
        Convenient method for converting an SLHA Doc object to SLHA format,
        either returned as a string or written to a file depending on whether
        the filename variable is None.
        
---Code snippet: class Block(object):

---Doc string: 
    Object representation of any BLOCK elements read from an SLHA file.

    Blocks have a name, may have an associated Q value, and contain a collection
    of data entries, each indexed by one or more keys. Entries in the dictionary
    are stored as numeric types (int or float) when a cast from the string in
    the file has been possible.

    Block is closely related to a Python dict (and, in fact, is implemented via
    an OrderedDict when possible). The preferred methods of entry access use the
    dict-like [] operator for getting and setting, and the keys() and items()
    methods for iteration. Purely iterating over the object behaves like keys(),
    as for an ordinary dict.

    Multiple (integer) indices are possible, especially for entries in mixing
    matrix blocks. These are now implemented in the natural way, e.g. for access
    to the (1,2) element of a mixing matrix block, use bmix[1,2] = 0.123 and
    print bmix[1,2]. The value() and set_value() functions behave
    similarly. Multi-element values are also permitted.

    It is possible, although not usual, to store unindexed values in a
    block. This is only supported when that entry is the only one in the block,
    and it is stored in the normal fashion but with None as the lookup key. The
    value() method may be used without a key argument to retrieve this value, if
    the is_single_valued() method returns True, and similarly the set_value()
    method may be used to set it if only one argument is supplied and the object
    is compatible.
    
---Code snippet:     def add_entry(self, args):

---Doc string: Add an entry to the block from an iterable (i.e. list or tuple) of
        strings, or from a whitespace-separated string.

        This method is just for convenience: it splits the single string
        argument if necessary and converts the list of strings into numeric
        types when possible. For the treatment of the resulting iterable see the
        set_value method.
        
---Code snippet:     def is_single_valued(self):

---Doc string: Return true if there is only one entry, and it has no index: the
        'value()' attribute may be used in that case without an argument.
---Code snippet:     def value(self, key=None, default=1):

---Doc string: Get a value from the block with the supplied key.

        If no key is given, then the block must contain only one non-indexed
        value otherwise an AccessError exception will be raised.\
        
---Code snippet:     def set_value(self, *args):

---Doc string: Set a value in the block via supplied key/value arguments.

        Indexing is determined automatically: any leading integers will be
        treated as a multi-dimensional index, with the remaining entries being a
        (potentially multi-dimensional) value. If all N args are ints, then the
        first N-1 are treated as the index and the Nth as the value.

        If there is only one arg it will be treated as the value of a
        single-valued block. In this case the block must already contain at most
        one non-indexed value otherwise an AccessError exception will be
        raised.\
        
---Code snippet:     def has_key(self, key):

---Doc string: Does the block have the given key?
---Code snippet:     def keys(self):

---Doc string: Access the block item keys.
---Code snippet:     def values(self):

---Doc string: Access the block item values.
---Code snippet:     def items(self, key=None):

---Doc string: Access the block items as (key,value) tuples.

        Note: The Python 3 dict attribute 'items()' is used rather than the
        'old' Python 2 'iteritems()' name for forward-looking compatibility.\
        
---Code snippet: class Decay(object):

---Doc string: 
    Object representing a decay entry on a particle decribed by the SLHA file.
    'Decay' objects are not a direct representation of a DECAY block in an SLHA
    file... that role, somewhat confusingly, is taken by the Particle class.

    Decay objects have three properties: a branching ratio, br, an nda number
    (number of daughters == len(ids)), and a tuple of PDG PIDs to which the
    decay occurs. The PDG ID of the particle whose decay this represents may
    also be stored, but this is normally known via the Particle in which the
    decay is stored.
    
---Code snippet: class Particle(object):

---Doc string: 
    Representation of a single, specific particle, decay block from an SLHA
    file.  These objects are not themselves called 'Decay', since that concept
    applies more naturally to the various decays found inside this
    object. Particle classes store the PDG ID (pid) of the particle being
    represented, and optionally the mass (mass) and total decay width
    (totalwidth) of that particle in the SLHA scenario. Masses may also be found
    via the MASS block, from which the Particle.mass property is filled, if at
    all. They also store a list of Decay objects (decays) which are probably the
    item of most interest.
    
---Code snippet: def readSLHA(spcstr, ignorenobr=False, ignorenomass=False, ignoreblocks=[]):

---Doc string: 
    Read an SLHA definition from a string, returning dictionaries of blocks and
    decays.

    If the ignorenobr parameter is True, do not store decay entries with a
    branching ratio of zero.

    If the ignorenomass parameter is True, parse file even if mass block is
    absent in the file (default is to raise a ParseError).
    
---Code snippet: def writeSLHABlocks(blocks, precision=8):

---Doc string: Return an SLHA definition as a string, from the supplied blocks dict.
---Code snippet: def writeSLHADecays(decays, ignorenobr=False, precision=8):

---Doc string: Return an SLHA decay definition as a string, from the supplied decays dict.
---Code snippet: def writeSLHA(doc, ignorenobr=False, precision=8):

---Doc string: Return an SLHA definition as a string, from the supplied blocks and decays dicts.
---Code snippet: def herwigid2pdgid(hwid):

---Doc string: 
    Convert a particle ID code in the HERWIG internal IDHW format (as used by
    ISAWIG) into its equivalent in the standard PDG ID code definition.
    
---Code snippet: def pdgid2herwigid(pdgid):

---Doc string: 
    Convert a particle ID code in the standard PDG ID code definition into
    its equivalent in the HERWIG internal IDHW format (as used by ISAWIG).
    
---Code snippet: def readISAWIG(isastr, ignorenobr=False):

---Doc string: 
    Read a spectrum definition from a string in the ISAWIG format, returning
    dictionaries of blocks and decays. While this is not an SLHA format, it is
    informally supported as a useful mechanism for converting ISAWIG spectra to
    SLHA.

    ISAWIG parsing based on the HERWIG SUSY specification format, from
    http://www.hep.phy.cam.ac.uk/~richardn/HERWIG/ISAWIG/file.html

    If the ignorenobr parameter is True, do not store decay entries with a
    branching ratio of zero.
    
---Code snippet: def writeISAWIG(doc, ignorenobr=False, precision=8):

---Doc string: 
    Return a SUSY spectrum definition in the format produced by ISAWIG for inut to HERWIG
    as a string, from the supplied SLHA blocks and decays dicts.

    ISAWIG parsing based on the HERWIG SUSY specification format, from
    http://www.hep.phy.cam.ac.uk/~richardn/HERWIG/ISAWIG/file.html

    If the ignorenobr parameter is True, do not write decay entries with a
    branching ratio of zero.
    
---Code snippet:                 def cmp_bottomlast(a, b):

---Doc string: Comparison function which always puts b/bbar last
---Code snippet:                         def cmp_gluonfirst(a, b):

---Doc string: Comparison function which always puts gluon first
---Code snippet:                     def cmp_quarkslast(a, b):

---Doc string: Comparison function which always puts quarks last
---Code snippet:                     def cmp_quarkslast(a, b):

---Doc string: Comparison function which always puts quarks last
---Code snippet:                     def cmp_quarkslast(a, b):

---Doc string: Comparison function which always puts quarks last
---Code snippet: def read(spcfile, **kwargs):

---Doc string: 
    Read an SLHA or ISAWIG file (or stdin).

    spcfile may either be a string filename or a file object.
    If a s string, the assumed file format is based from the
    filename; if a file it is assumed to be SLHA format.

    Other keyword parameters are passed to readSLHA/readISAWIG.
    
---Code snippet: def readSLHAFile(spcfile, **kwargs):

---Doc string: 
    Read an SLHA file, returning dictionaries of blocks and decays.

    Other keyword parameters are passed to readSLHA.
    
---Code snippet: def readISAWIGFile(isafile, **kwargs):

---Doc string: 
    Read a spectrum definition from a file in the ISAWIG format, returning
    dictionaries of blocks and decays. While this is not an SLHA format, it is
    informally supported as a useful mechanism for converting ISAWIG spectra to
    SLHA.

    isafile may either be a string filename or a file object.

    Other keyword parameters are passed to readISAWIG.
    
---Code snippet: def write(spcfile, doc, **kwargs):

---Doc string: 
    Write to an SLHA or ISAWIG file (or stdout).

    spcfile may either be a string filename or a file object.
    If a s string, the assumed file format is based from the
    filename; if a file it is assumed to be SLHA format.

    Other keyword parameters are passed to writeSLHA/writeISAWIG.
    
---Code snippet: def writeSLHAFile(spcfile, doc, **kwargs):

---Doc string: 
    Write an SLHA file from the supplied blocks and decays dicts.

    Other keyword parameters are passed to writeSLHA.
    
---Code snippet: def writeISAWIGFile(isafile, doc, **kwargs):

---Doc string: 
    Write an ISAWIG file from the supplied blocks and decays dicts.

    isafile may either be a string filename or a file object.

    Other keyword parameters are passed to writeISAWIG.
    
-----------File: smodels/tools/nllFast.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: nllFast
   :synopsis: This module provides methods to access the nllfast grid and
              compute k-factors (when available) to SUSY pair 
              production cross-sections.

.. moduleauthor:: Suchita Kulkarni <suchita.kulkarni@gmail.com>
.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>


---Code snippet: def getKfactorsFor(pIDs, sqrts, slhafile, pdf='cteq'):

---Doc string: 
    Read the NLLfast grid and returns a pair of k-factors (NLO and NLL) for the
    pair.

    :returns: k-factors = None, if NLLfast does not contain the process; uses
              the slhafile to obtain the SUSY spectrum.
    
    
---Code snippet: def getProcessName(pIDs):

---Doc string: 
    Return the process name (in NLLfast notation) for the pair production of
    pIDs.
    
    :returns: None, if the particle ID pair is not contained in NLLfast
    
    
---Code snippet: def runNLLfast(nll_run, nllpath):

---Doc string: 
    Execute NLLfast with command nll_run at nllpath.
    
    :returns: NLLfast output as a string
    
    
---Code snippet: def getKfactorsFrom(output):

---Doc string: 
    Read NLLfast output and return the k-factors.
    
    
---Code snippet: def interpolateKfactors(kFacsVector, xval):

---Doc string: 
    Interpolate a list of k-factor  values from
    kFacsVector = [[x0,[k1,k2,..]], [x1,[k1,k2,..],...].
    
    :returns: list of interpolated k-factor values at x-value xval
    
    
---Code snippet: def getDecoupledKfactors(nllpath,process,energy,pdf,mass):

---Doc string: 
    Compute k-factors in the decoupled (squark or gluino) regime for the process.
    If a decoupled grid does not exist for the process, return None
    
---Code snippet:     if process != 'sb' and process != 'gg': return None
    elif process == 'sb': process_dcpl = 'sdcpl'
    elif process == 'gg': process_dcpl = 'gdcpl'    
    nll_run = "./nllfast_" + energy + " %s %s %s" % \
                      (process_dcpl, pdf, mass)
    nll_output = runNLLfast(nll_run, nllpath)
    if "K_NLO" in nll_output:
        return getKfactorsFrom(nll_output)
    else: return None
if __name__ == "__main__":

---Doc string: 
    Calculate k factors for a pid pair.
    
    
-----------File: validation/database/2012/SUS12011/sms.py
No doc strings
-----------File: smodels/tools/physicsUnits.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: physicsUnits
   :synopsis: This introduces physical units (GeV, fb) to the framework.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet: def addunit(value, unitstring):

---Doc string: 
    Add units to values.
    
    Allow to turn this functionality off, in case "units" is not installed.
    
    
---Code snippet: def rmvunit(value, unitstring):

---Doc string: 
    Remove units from values.
    
    Allow to turn this functionality off, in case "units" is not installed.
    
    
---Code snippet:     if not useUnits:
        return value
    if useUnits:
        if type(value) != type(1.*GeV):
            return value
        if unitstring == "GeV":
            return value.asNumber(GeV)
        if unitstring == "TeV":
            return value.asNumber(TeV)
        if unitstring == "fb":
            return value.asNumber(fb)
        if unitstring == "pb":
            return value.asNumber(pb)
        if unitstring == "fb-1":
            return value.asNumber(1 / fb)
        logger.warning("Unknown unit: " + unitstring)
        return value
if __name__ == "__main__":

---Doc string: 
    Called as script, will print some physicsUnits.
    
    
-----------File: tools/MSSM_qNumbers.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: MSSM_qNumbers
   :synopsis: The quantum numbers of particles in the MSSM

.. moduleauthor:: Ursula Laa <Ursula.Laa@assoc.oeaw.ac.at>


-----------File: validation/database/2012/SUS12009/sms.py
No doc strings
-----------File: experiment/smsHelpers.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: experiment.smsHelpers
   :synopsis: Contains private helper functions to access the SMS results.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>
.. moduleauthor:: Ursula Laa <Ursula.Laa@assoc.oeaw.ac.at>
.. moduleauthor:: Doris Proschofsky <Doris.Proschofsky@assoc.oeaw.ac.at>
.. moduleauthor:: Wolfgang Magerl <wolfgang.magerl@gmail.com>


---Code snippet: def getRun(analysis, run=None):

---Doc string: 
    Search for an analysis.

    If a specific run is given, check if results are present.

    :returns: run; None, if not found;

    
---Code snippet: def getLines(analysis, run, label="condition"):

---Doc string: 
    Get all <label> lines in info.txt for an analysis-run pair.

    
---Code snippet: def getMetaInfoField(analysis, field, run=None):

---Doc string: 
    Get one specific entry of the meta info.

    
---Code snippet: def _parseMetaInfo(analysis, run):

---Doc string: 
    Get all the meta information for a given analysis-run pair.

    
---Code snippet: def getUpperLimitDictionary(analysis, topology, run, expected=False):

---Doc string: 
    Returns a dictionary containing the raw Upper Limit data for the analysis
    and topology. 

    
---Code snippet: def hasDictionary(analysis, run=None, topology=None):

---Doc string: 
    Check if available upper limits are in dictionary format.

    
---Code snippet: def databaseVersion(astuple=False):

---Doc string:  prints out version number of the *database* 
-----------File: smodels/validation/database/2012/SUS12005/sms.py
No doc strings
-----------File: smodels/theory/__init__.py
---Code snippet: NOT FOUND
---Doc string: 
This Package is intended to contain everything related to theory:

   * cross section calculation code
   * sms decomposition code (LHE-based, SLHA-based)
   * some more tools, e.g. for reading/writing slha files, or particle names
   

-----------File: tests/testTx.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: testTx
   :synopsis: Tests with Tx slha input files.
    
.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>
    

---Code snippet:     def testT1(self):
        self.logger.info ( "T1" )

---Doc string:  test with the T1 slha input file 
-----------File: smodels/tests/testSlhaDecomposition.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: testSlhaDecomposition
   :synopsis: Checks slha decomposition, alongside with compression
    
.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>
    

---Code snippet:     def test(self):
        self.logger.info ( "test decomposition, no compression" )

---Doc string:  test the decomposition with no compression 
-----------File: tools/__init__.py
---Code snippet: NOT FOUND
---Doc string: 
This package contains all code that cannot be classified as being part of
*experiment* or *theory*.


-----------File: smodels/experiment/smsAnalysisFactory.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: experiment.smsAnalysisFactory
   :synopsis: Create a list of analysis objects from a results database.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>
.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>


---Code snippet: def load(analyses=None, topologies=None, sqrts=[7, 8], usePrivate=None):

---Doc string: 
    Create an analysis objects from the info given in the SMS results database.
)
    :param analyses: If a list of analyses is passed, create only objects for
                     these analyses (the database naming convention is used).
    :param topologies: If a list of topologies is passed, only these topologies
                       are considered.
    :param sqrts: Array of center-of-mass energies of the analyses that are to
                  be considered.
    :param usePrivate: Include analyses flagged as private.
    :returns: list of analyses
    
    
---Code snippet: def _getRealTopo(tx):

---Doc string: 
    Get real topology, e.g., T3w025 -> T3w, etc.
    
    
---Code snippet: def _getElementsEffs(constraint,conditions):

---Doc string: 
    Generate a dictionary of elements with their simple efficiencies as values.    
    Efficiencies are = 1. if the element appears in the constraint or conditions.
    
    
---Code snippet: def _getArray(constraint):

---Doc string: 
    Get number of vertices, branches and insertions from a constraint string.
    
    This maps, e.g.,
    2*([[['L'],['L']],[['L'],['nu']]] + [[['L'],['L']],[['nu'],['L']]])
    to
    [[['L'],['L']],[['L'],['nu']]]
    
    
-----------File: smodels/validation/plots_closure/plotExcludedT2.py
No doc strings
-----------File: validation/database/2012/SUS12003/sms.py
No doc strings
-----------File: experiment/experimentExceptions.py
---Code snippet: NOT FOUND
---Doc string: 
.. module:: experiment.experimentExceptions
   :synopsis: Provides exception classes for the experiment package.
    
.. moduleauthor:: Wolfgang Magerl <wolfgang.magerl@gmail.com>
    

---Code snippet: class MetaInfoError(Exception):

---Doc string: 
    Exception class that is raised when a meta info field cannot be found.
    
    
-----------File: smodels/tools/ioObjects.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
    .. module:: ioObjects
    :synopsis: Definitions of input/output parameters which are read from parameter.in
    
    .. moduleauthor:: Ursula Laa <Ursula.Laa@assoc.oeaw.ac.at>    
    .. moduleauthor:: Suchita Kulkarni <suchita.kulkarni@gmail.com>

---Code snippet: class ExptResults:

---Doc string: 
    A class to store all relevant information for one result
    
---Code snippet: class ResultList(Printer):

---Doc string: 
    Class that collects ExptResults objects and has a predefined printout
    
---Code snippet:     def formatData(self):

---Doc string: 
        to access printout format
        
---Code snippet: class OutputStatus(Printer):

---Doc string: 
    Object that holds all status information and has a predefined printout 
    
---Code snippet:     def formatData(self):

---Doc string: 
        to access printout format
        
---Code snippet: class MissingTopo():

---Doc string: 
    Object to describe one missing topology result
    
---Code snippet: class MissingTopoList(Printer):

---Doc string: 
    Object to find and collect MissingTopo objects, plus printout functionality
    
-----------File: tests/testCompression.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: testCompression
   :synopsis: Checks the compression algorithms
    
.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>
    

---Code snippet:     def testInvisiblePositive(self):

---Doc string:  test the invisible compression, a positive example 
---Code snippet:     def testInvisibleNegative(self):

---Doc string:  test the invisible compression, a negative example 
---Code snippet:     def testMass(self):

---Doc string:  test the mass compression, a positive and negative example 
-----------File: smodels/validation/plots_closure/plotExcluded2.py
No doc strings
-----------File: smodels/tests/testAsciiGraph.py
---Code snippet: #!/usr/bin/env python

---Doc string: 
.. module:: testAsciiGraph
   :synopsis: Tests the ascii grapher.
              Depends also on lheReader, lheDecomposer.

.. moduleauthor:: Wolfgang Waltenberger <wolfgang.waltenberger@gmail.com>


---Code snippet:     def orig(self):
        return 

---Doc string:  /------------\\
 |    q  q    |
 |    \ /     |
 | ----*----  |
 | ----*----  |
 |    / \     |
 |    q  q    |
 \------------/

---Code snippet:     def testGraph(self):

---Doc string:  draw ascii graph 
