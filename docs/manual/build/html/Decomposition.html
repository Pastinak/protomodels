

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Decomposition into Simplified Models &mdash; SModelS 1.0.93 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="SModelS 1.0.93 documentation" href="index.html"/>
        <link rel="up" title="SModelS Structure" href="Structure.html"/>
        <link rel="next" title="Theory Predictions" href="TheoryPredictions.html"/>
        <link rel="prev" title="Basic Input" href="BasicInput.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> SModelS
          

          
          </a>

          
            
            
              <div class="version">
                1.0.93
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="SModelSDefs.html">Basic Concepts and Definitions</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Structure.html">SModelS Structure</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="BasicInput.html">Basic Input</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Decomposition into Simplified Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#slha-based-decomposition">SLHA-based Decomposition</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#minimum-decomposition-weight">Minimum Decomposition Weight</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#lhe-based-decomposition">LHE-based Decomposition</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compression-of-elements">Compression of Elements</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#mass-compression">Mass Compression</a></li>
<li class="toctree-l4"><a class="reference internal" href="#invisible-compression">Invisible Compression</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#element-sorting">Element Sorting</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="TheoryPredictions.html">Theory Predictions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ConfrontPredictions.html">Confronting Predictions with Experimental Limits</a></li>
<li class="toctree-l2"><a class="reference internal" href="DatabaseStructure.html">Database of Experimental Results</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Tools.html">SModelS Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="Installation.html">Installation and Deployment</a></li>
<li class="toctree-l1"><a class="reference internal" href="RunningSModelS.html">Running SModelS</a></li>
<li class="toctree-l1"><a class="reference internal" href="Examples.html">More Examples</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">SModelS</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 







<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
        <li><a href="Structure.html">SModelS Structure</a> &raquo;</li>
      
    <li>Decomposition into Simplified Models</li>
    <li class="wy-breadcrumbs-aside">
      
          
          <a href="_sources/Decomposition.txt" rel="nofollow"> View page source</a>
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <span class="target" id="index-0"></span><div class="section" id="decomposition-into-simplified-models">
<span id="decomposition"></span><h1>Decomposition into Simplified Models<a class="headerlink" href="#decomposition-into-simplified-models" title="Permalink to this headline">¶</a></h1>
<p>Given an input model, the first task of SModelS is to decompose
the full model into a sum of <a class="reference internal" href="TheoryDefinitions.html#element"><span class="std std-ref">elements</span></a>.
Based on the input format, which can be</p>
<ul class="simple">
<li>a SLHA (SUSY Les Houches Accord) file or</li>
<li>a LHE (Les Houces Event) file</li>
</ul>
<p>as explained in the <a class="reference internal" href="BasicInput.html"><span class="doc">Basic Input</span></a> section,
two distinct (but similar) decomposition methods are applied:
the <a class="reference internal" href="#slhadecomp"><span class="std std-ref">SLHA-based</span></a> or the <a class="reference internal" href="#lhedecomp"><span class="std std-ref">LHE-based</span></a> decomposition.</p>
<div class="section" id="slha-based-decomposition">
<span id="slhadecomp"></span><h2>SLHA-based Decomposition<a class="headerlink" href="#slha-based-decomposition" title="Permalink to this headline">¶</a></h2>
<p>The SLHA file describing the input model is required to contain the masses of all
the BSM states as well as their production cross-sections and decay branching ratios. All the above information must follow the guidelines of the SLHA format. In particular, the cross-sections also have to be included
as SLHA blocks according to the <a class="reference internal" href="BasicInput.html#xsecslha"><span class="std std-ref">SLHA cross-section format</span></a>.</p>
<p>Once the production cross-sections are read from the input file, all the cross-sections for <em>production
of two</em> Z<sub>2</sub>-odd <em>states</em> are stored and serve as the initial step for the decomposition. (All the other cross-sections
with a different number of Z<sub>2</sub>-odd states are ignored.)
Starting from these primary mothers, all the possible decays are generated
according to the information contained in the DECAY blocks. This procedure is represented in the figure below:</p>
<a class="reference internal image-reference" href="_images/decomp1B.png" id="decomp1"><img alt="_images/decomp1B.png" id="decomp1" src="_images/decomp1B.png" style="width: 45%;" /></a>
<p>Each of the possible cascade decays for each mother corresponds to a <a class="reference internal" href="TheoryDefinitions.html#branch"><span class="std std-ref">branch</span></a>.
In order to finally generate <a class="reference internal" href="TheoryDefinitions.html#element"><span class="std std-ref">elements</span></a>, all the branches are combined in pairs according to the production cross-sections,
as shown below:</p>
<a class="reference internal image-reference" href="_images/decomp2B.png" id="decomp2"><img alt="_images/decomp2B.png" id="decomp2" src="_images/decomp2B.png" style="width: 65%;" /></a>
<p>For instance, assume [b1,b2,b3] and [B1,B2] represent all possible branches (or cascade decays)
for the primary mothers A and B, respectively. Then, if a production cross-section for <span class="math">\(pp \rightarrow A+B\)</span> is given in the input file, the following elements will be generated:</p>
<blockquote>
<div>[b1,B1], [b1,B2], [b2,B1], [b2,B2], [b3,B1] and [b3,B2]</div></blockquote>
<p>Each of the <a class="reference internal" href="TheoryDefinitions.html#element"><span class="std std-ref">elements</span></a> generated according to the procedure just described will also
store its weight, which equals its production cross-section times all the branching ratios appearing in it.
In order to avoid a too large number of elements, only those satisfying a <a class="reference internal" href="#minweight"><span class="std std-ref">minimum weight</span></a> requirement are kept.
Furthermore, the elements are grouped according to their <a class="reference internal" href="TheoryDefinitions.html#topology"><span class="std std-ref">topologies</span></a>. The final output of the
SLHA decomposition is a list of such topologies, where each topology contains a list of the elements generated during the decomposition.</p>
<ul class="simple">
<li><strong>The SLHA decomposition is implemented by the</strong> <a class="reference external" href="../../../documentation/build/html/theory.html#theory.slhaDecomposer.decompose">SLHA decompose method</a></li>
</ul>
<div class="section" id="minimum-decomposition-weight">
<span id="minweight"></span><h3>Minimum Decomposition Weight<a class="headerlink" href="#minimum-decomposition-weight" title="Permalink to this headline">¶</a></h3>
<p>Some models may contain a large number of new states and each may have a large number of possible decays.
As a result, long cascade decays are possible and the number of elements generated by the decomposition process
may become too large, and the computing time too long.
For most practical purposes, however, elements with extremely small weights (cross-section times BRs)
can be discarded, since they will fall well below the experimental limits. Therefore, during the SLHA decomposition,
whenever an element is generated with a weight below some minimum value, this element (and all elements derived from it) is ignored.
The minimum weight to be considered is given by the <a class="reference external" href="../../../documentation/build/html/theory.html#theory.slhaDecomposer.decompose">sigcut</a> parameter
and is easily adjustable (see <a class="reference external" href="../../../documentation/build/html/theory.html#theory.slhaDecomposer.decompose">slhaDecomposer.decompose</a>)</p>
<p>Note that, when computing the <a class="reference internal" href="TheoryPredictions.html"><span class="doc">theory predictions</span></a>, the weight of several <a class="reference internal" href="TheoryDefinitions.html#element"><span class="std std-ref">elements</span></a> can be combined together. Hence
it is recommended to set the value of <a class="reference external" href="../../../documentation/build/html/theory.html#theory.slhaDecomposer.decompose">sigcut</a>
approximately one order of magnitude below the minimum signal cross-sections the experimental data can constrain.</p>
</div>
</div>
<div class="section" id="lhe-based-decomposition">
<span id="lhedecomp"></span><h2>LHE-based Decomposition<a class="headerlink" href="#lhe-based-decomposition" title="Permalink to this headline">¶</a></h2>
<p>More general models can be input through an LHE event file containing parton-level events, including the production of the primary
mothers and their cascade decays. Each event can then be directly mapped to an <a class="reference internal" href="TheoryDefinitions.html#element"><span class="std std-ref">element</span></a> with the element weight
corresponding to the event weight.
Finally, identical elements can be combined together (adding their weights). The procedure is represented in the example below:</p>
<a class="reference internal image-reference" href="_images/eventExample.png" id="event"><img alt="_images/eventExample.png" id="event" src="_images/eventExample.png" style="width: 95%;" /></a>
<p>Notice that, for the LHE decomposition, the <a class="reference internal" href="TheoryDefinitions.html#element"><span class="std std-ref">elements</span></a> generated are restricted to the events in the input file. Hence,
the uncertainties on the elements weights (and which elements are actually generated by the model)
are fully dependent on the Monte Carlo statistics used to generate the LHE file.
Also, when generating the events it is important to ensure that no mass smearing is applied, so the events
always contain the same mass value for a given particle.</p>
<ul class="simple">
<li><strong>The LHE decomposition is implemented by the</strong> <a class="reference external" href="../../../documentation/build/html/theory.html#theory.lheDecomposer.decompose">LHE decompose method</a></li>
</ul>
</div>
<div class="section" id="compression-of-elements">
<span id="elementcomp"></span><h2>Compression of Elements<a class="headerlink" href="#compression-of-elements" title="Permalink to this headline">¶</a></h2>
<p>During the decomposition process it is possible to perform several simplifications on
the <a class="reference internal" href="TheoryDefinitions.html#element"><span class="std std-ref">elements</span></a> generated. In both the <a class="reference internal" href="#lhedecomp"><span class="std std-ref">LHE</span></a> and <a class="reference internal" href="#slhadecomp"><span class="std std-ref">SLHA</span></a>-based decompositions, two useful
simplifications are possible: <a class="reference internal" href="#masscomp"><span class="std std-ref">Mass Compression</span></a> and <a class="reference internal" href="#invcomp"><span class="std std-ref">Invisible Compression</span></a>.
The main advantage of performing these compressions is that the simplified <a class="reference internal" href="TheoryDefinitions.html#element"><span class="std std-ref">element</span></a> is
always shorter (has fewer cascade decay steps), which makes it more likely to be constrained by experimental
results. The details behind the compression methods are as follows:</p>
<div class="section" id="mass-compression">
<span id="masscomp"></span><h3>Mass Compression<a class="headerlink" href="#mass-compression" title="Permalink to this headline">¶</a></h3>
<p>In case of small mass differences, the decay of an <a class="reference internal" href="TheoryDefinitions.html#odd-states"><span class="std std-ref">intermediate state</span></a> to a nearly degenerate
one will in most cases produce soft <a class="reference internal" href="TheoryDefinitions.html#final-states"><span class="std std-ref">final states</span></a>, which can not be experimentally detected.
Consequently, it is a good approximation to neglect the soft <a class="reference internal" href="TheoryDefinitions.html#final-states"><span class="std std-ref">final states</span></a> and <em>compress</em> the respective
decay, as shown below:</p>
<a class="reference internal image-reference" href="_images/massCompB.png" id="masscompfig"><img alt="_images/massCompB.png" id="masscompfig" src="_images/massCompB.png" style="width: 80%;" /></a>
<p>After the compression, only the lightest of the two near-degenerate masses are kept in the element, as shown <a class="reference internal" href="#masscompfig"><span class="std std-ref">above</span></a>.
The main parameter which controls the compression is <a class="reference external" href="../../../documentation/build/html/theory.html#theory.element.Element.massCompress">minmassgap</a>,
which corresponds to the maximum value of <span class="math">\(\epsilon\)</span>
in the <a class="reference internal" href="#masscompfig"><span class="std std-ref">figure above</span></a> to which the compression is performed:</p>
<div class="math">
\[\begin{split}&amp; \mbox{if } |M_j - M_{j+1}| &lt; minmassgap \rightarrow \mbox{the decay is compressed}\\
&amp; \mbox{if } |M_j - M_{j+1}| &gt; minmassgap \rightarrow \mbox{the decay is NOT compressed}\\\end{split}\]</div>
<p>Note that the compression is an approximation since the final
states, depending on the boost of the parent state, may not always be soft.
It is recommended to choose values of <a class="reference external" href="../../../documentation/build/html/theory.html#theory.element.Element.massCompress">minmassgap</a>
between 1-10 GeV; the default value is 5 GeV.</p>
<ul class="simple">
<li><strong>Mass compression is implemented by the</strong> <a class="reference external" href="../../../documentation/build/html/theory.html#theory.element.Element.massCompress">massCompress</a> <strong>method</strong></li>
</ul>
<p>and can be easily turned on/off by the flag <em>doCompress</em> in the <a class="reference internal" href="#slhadecomp"><span class="std std-ref">SLHA</span></a> or <a class="reference internal" href="#lhedecomp"><span class="std std-ref">LHE</span></a> decompositions</p>
</div>
<div class="section" id="invisible-compression">
<span id="invcomp"></span><h3>Invisible Compression<a class="headerlink" href="#invisible-compression" title="Permalink to this headline">¶</a></h3>
<p>Another class of compression is possible when
the <a class="reference internal" href="TheoryDefinitions.html#final-states"><span class="std std-ref">final states</span></a> in the last decay as well as the last <a class="reference internal" href="TheoryDefinitions.html#odd-states"><span class="std std-ref">intermediate state</span></a>
are both invisible experimentally.
The most common example is</p>
<div class="math">
\[A \rightarrow \nu + B\]</div>
<p>as the last step of the decay chain, where <span class="math">\(B\)</span> is an insivible particle leading to a MET signature. Since both the neutrino and
<span class="math">\(B\)</span> are invisible, for all experimental purposes the effective MET object is <span class="math">\(B + \nu = A\)</span>.
Hence it is possible to omit the last step in the cascade decay, resulting in a compressed element.
Note that this compression can be applied consecutively to several steps of the cascade decay if all of them
contain only invisible final states:</p>
<a class="reference internal image-reference" href="_images/invCompB.png" id="massinvpfig"><img alt="_images/invCompB.png" id="massinvpfig" src="_images/invCompB.png" style="width: 80%;" /></a>
<ul class="simple">
<li><strong>Invisible compression is implemented by the</strong> <a class="reference external" href="../../../documentation/build/html/theory.html#theory.element.Element.invisibleCompress">invisibleCompress</a> <strong>method</strong></li>
</ul>
<p>and can be easily turned on/off by the flag <em>doInvisible</em> in the <a class="reference internal" href="#slhadecomp"><span class="std std-ref">SLHA</span></a> or <a class="reference internal" href="#lhedecomp"><span class="std std-ref">LHE</span></a> decompositions</p>
</div>
</div>
<div class="section" id="element-sorting">
<h2>Element Sorting<a class="headerlink" href="#element-sorting" title="Permalink to this headline">¶</a></h2>
<p>In order to improve the code performance, elements created during decomposition and
sharing a commong global <a class="reference internal" href="TheoryDefinitions.html#topology"><span class="std std-ref">topology</span></a> are sorted.
Sorting allows for an easy ordering of the elements belonging to a topology and
faster element comparison.
Elements are sorted according to its branches. Branches are compared according to
the following properties:</p>
<ul class="simple">
<li>Number of vertices</li>
<li>Number of final states in each vertex</li>
<li>Final state particles (particles belonging to the same vertex are alphabetically sorted)</li>
<li>Mass array</li>
</ul>
<p>As an example, consider the three elements below:</p>
<a class="reference internal image-reference" href="_images/elSorting.png" id="elementsorting"><img alt="_images/elSorting.png" id="elementsorting" src="_images/elSorting.png" style="width: 80%;" /></a>
<p>The correct ordering of the above elements is:</p>
<p>Element 3 &lt; Element 2 &lt; Element 1</p>
<p>Element 1 is &#8216;larger&#8217; than the other two since it has a larger number of vertices.
Elements 2 and 3  are identical, except for their masses. Since the mass array of
Element 3 is smaller than the one in Element 2, the former is &#8216;smaller&#8217; than the latter.
Finally if all the branch features listed above are identical for both branches, the
elements being compared are considered to be equal.
Futhermore, the branches belonging to the same element are also sorted. Hence, if an element
has two branches:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">element</span> <span class="o">=</span> <span class="p">[</span><span class="n">branch1</span><span class="p">,</span> <span class="n">branch2</span><span class="p">],</span>
</pre></div>
</div>
<p>it implies:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">branch1</span> <span class="o">&lt;</span> <span class="n">branch2</span>
</pre></div>
</div>
<ul class="simple">
<li><strong>Branch sorting is implemented by the</strong> <a class="reference external" href="../../../documentation/build/html/theory.html#theory.element.Element.sortBranches">sortBranches</a> <strong>method</strong></li>
</ul>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="TheoryPredictions.html" class="btn btn-neutral float-right" title="Theory Predictions" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="BasicInput.html" class="btn btn-neutral" title="Basic Input" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Federico Ambrogi, Sabine Kraml, Suchita Kulkarni, Ursula Laa,Andre Lessa, Veronika Magerl, Wolfgang Magerl, Doris Proschofsky, Michael Traub, Jory Sonneveld, Wolfgang Waltenberger.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0.93',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>