.. index:: Theory Predictions

.. |EM| replace:: :ref:`EM-type <EMtype>`
.. |UL| replace:: :ref:`UL-type <ULtype>`
.. |EMr| replace:: :ref:`EM-type result <EMtype>`
.. |ULr| replace:: :ref:`UL-type result <ULtype>`
.. |EMrs| replace:: :ref:`EM-type results <EMtype>`
.. |ULrs| replace:: :ref:`UL-type results <ULtype>`
.. |ExpRes| replace:: :ref:`Experimental Result<ExpResult>`
.. |ExpRess| replace:: :ref:`Experimental Results<ExpResult>`
.. |Dataset| replace:: :ref:`Data Set<DataSet>`
.. |Datasets| replace:: :ref:`Data Sets<DataSet>`
.. |dataset| replace:: :ref:`data set<DataSet>`
.. |datasets| replace:: :ref:`data sets<DataSet>`
.. |element| replace:: :ref:`element <element>`
.. |elements| replace:: :ref:`elements <element>`
.. |topology| replace:: :ref:`topology <topology>`
.. |topologies| replace:: :ref:`topologies <topology>`
.. |sigBR| replace:: :math:`\sigma \times BR`
.. |sigBRe| replace:: :math:`\sigma \times BR \times \epsilon`

.. _theoryPredictions:

Theory Predictions
==================

The :doc:`decomposition <Decomposition>` of the input model as a sum of |elements| is the
first step for confronting the model with the experimental limits.
The next step consists of computing the relevant signal 
(or *theory predictions*) for comparison with the experimental limits. Below we describe the procedure
for the computation of the theory predictions after the model has been decomposed.


Computing Theory Predictions
----------------------------

As discussed in :doc:`Database Definitions <DatabaseDefinitions>`, SModelS allows
for two different types of |ExpRess|: |ULrs| and |EMrs|. 

Each of them requires different theoretical predictions to be compared against experimental data.
Since |ULrs| constrains |sigBR|,
SModelS must compute the theoretical value of |sigBR| summing only over the |elements|
appearing in the respective :ref:`constraint <ULconstraint>`.
On the other hand, |EMrs| constrain |sigBRe| for a given signal region.
Consequently, in this case SModelS must compute |sigBRe| using the efficiency maps for
the corresponding signal region (or |Dataset|). All the |elements| generated by the
:doc:`decomposition <Decomposition>` may contribute (with their respective weights) to
|sigBRe| as long as there is an efficiency map for the |element|. 


Although the details of the computation procedure differ depending on the type
of analysis, the procedure can always be divided in two main steps:
*Element Selection* and *Element Clustering*. The first step is trivial for |ULrs|,
but more involved for |EMrs|, while the opposite is true for the clustering of |elements|.
Once the |elements| have been selected and clustered, the theory prediction for the analysis is given by
the sum of all the |element| weights (|sigBR|) belonging to the same cluster:

.. math::
   \mbox{theory prediction } = \sum_{elements\, in\, cluster} \mbox{element weight}
   :label: thpred

In the case of |ULrs|, there might be several clusters (see :ref:`Element Clustering <ULcluster>`)
for a given |ExpResult|, resulting in a list of theory predictions for the corresponding result. Each theory prediction must then
be individually confronted with the 95% experimental upper limit obtained from the corresponding UL map.

For |EMrs|, the final theory prediction must be compared against the
signal upper limit for the corresponding signal region. Notice that this upper limit is a fixed number for
all predictions and depends only on the number of expected and observed events in the signal region
(as well as their uncertainties).  


Below we describe the method for computing the theory predictions for each type
of analysis separately.

* **Theory predictions are computed using the** `theoryPredictionsFor <../../../documentation/build/html/theory.html#theory.theoryPrediction.theoryPredictionsFor>`_ **method** 


Theory Predictions for Upper Limit Results
------------------------------------------

In order to compute the signal cross-sections for a given |ULr|, so it can be compared
against the upper limits, it is first necessary to select the |elements| generated by the model 
:doc:`decomposition <Decomposition>` and then cluster them according to their masses.
These two steps are described below. 

.. _ULselection:

Element Selection
^^^^^^^^^^^^^^^^^

An |ULr| holds upper limits for the cross-sections of an |element|
or sum of |elements|. Consequently, the first step for computing the theory predictions for the corresponding
analysis is to select the |elements| that appear in the :ref:`constraint <ULconstraint>`.
This is conveniently done attributing to each |element| an efficiency equal to 1 (0) 
if the |element| appears (does not appear) in the :ref:`constraint <ULconstraint>`.
After all the |elements| weights (:math:`\sigma \times BR`) have been rescaled
by these ''trivial'' efficiencies, only the ones with non-zero weights are relevant for the analysis.
The |element| selection is then trivially achieved by selecting all the |elements| with non-zero weights.

The procedure described above is illustrated graphically in the figure below for the simple example where the 
:ref:`constraint <ULconstraint>` is :math:`[[[e^+]],[[e^-]]]\,+\,[[[\mu^+]],[[\mu^-]]]`.

.. image:: images/ULselection.png
   :height: 500px 



* **The element selection is implemented by the** `getElementsFrom <../../../documentation/build/html/theory.html#theory.theoryPrediction._getElementsFrom>`_ **method**

.. _ULcluster:

Element Clustering
^^^^^^^^^^^^^^^^^^

Naively one would expect that after all the |elements| appearing in the :ref:`analysis constraint <ULconstraint>`
have been selected, it is trivial to compute the theory prediction for the analysis: one must simply sum up the weights (:math:`\sigma \times BR`) of all the |elements|.
However, the selected |elements| usually differ in their masses [*]_ and the
experimental limit (see :ref:`Upper Limit constraint <ULconstraint>`) assumes that all the |elements| appearing
in the :ref:`constraint <ULconstraint>` have the same mass (or mass array).
As a result, the selected |elements| must be grouped into *clusters* of equal masses.
When grouping the |elements|, however, one must allow for small mass differences, 
since the experimental efficiencies should not be strongly sensitive to small mass
differences. For instance, assume two |elements| contain identical mass arrays, except for the parent masses
which differ by 1 MeV. In this case it is obvious that for all experimental purposes the two |elements|
have identical masses and should contribute to the same theory prediction (e.g. their weights should be
added when computing the signal cross-section). 
Unfortunately there is no way to
unambiguously define ''similar masses'' and the definition should depend on the |ExpRes|, since
different results will be more or less dependent to mass differences. SModelS uses an UL map-dependent
measure of the distance between two |element| masses, as described in :ref:`Mass Distance <massdist>`.


If two of the selected |elements| have a :ref:`mass distance <massdist>` smaller
than a maximum value (defined by `maxDist <../../../documentation/build/html/theory.html#theory.clusterTools.clusterElements>`_),
they are gouped in the same mass cluster, as illustrated by the example below:



.. image:: images/ULcluster.png
   :height: 550px


Once all the |elements| have been clustered, their weights can finally be added together
and compared against the experimental upper limit.



* **The clustering of elements is implemented by the** `clusterElements <../../../documentation/build/html/theory.html#theory.clusterTools.clusterElements>`_  **method**.

.. _massdist:  

Mass Distance
^^^^^^^^^^^^^

As mentioned :ref:`above <ULcluster>`, in order to cluster the |elements| it is necessary
to determine whether two |elements| have similar masses (see |element| and :ref:`Bracket Notation <bracketnotation>`
for more details on |element| mass).
Since an absolute definition of ''similar masses'' is not possible and the sensitivity to mass differences
depend on the experimental result, SModelS uses an ''upper limit map-dependent'' definition. For each |element|'s mass array,
the upper limit for the corresponding mass values is obtained from the UL map (see |ULr|).
This way, each mass array is mapped to a single number (the cross-section upper limit for the experimental result).
Then the distance between the two |element|'s masses is simply given by the relative difference between their respective
upper limits. More explicitly:

.. math::

   \mbox{Element } A\; (& M_A = [[M1,M2,...],[m1,m2,...]]) \rightarrow \mbox{ Upper Limit}(M_A) = x\\
   \mbox{Element } B\; (& M_B = [[M1',M2',...],[m1',m2',...]]) \rightarrow \mbox{ Upper Limit}(M_B) = y\\
                                       & \Rightarrow \mbox{mass distance}(A,B) = \frac{|x-y|}{(x+y)/2}
   
where :math:`M_A,M_B` (:math:`x,y`) are the mass arrays (upper limits) for the |elements| A and B, respectively.
If the mass distance of two |elements| is smaller than `maxDist <../../../documentation/build/html/theory.html#theory.clusterTools.clusterElements>`_,
the two masses are considered similar.

Notice that the above definition of mass distance quantifies the experimental analysis
sensitivity to mass differences, which is the relevant parameter when :ref:`clustering elements <ULcluster>`.
Also, a check is performed to ensure that masses with very distinct values but similar upper limits are not
clustered together.

* **The mass distance function is implemented by the** `distance <../../../documentation/build/html/theory.html#theory.auxiliaryFunctions.distance>`_ **method**



Theory Predictions for Efficiency Map Results
---------------------------------------------

In order to compute the signal cross-sections for a given |EMr|, so it can be compared
to the signal region limits, it is first necessary to apply the efficiencies (see |EMr|) to all the |elements| generated
by the model :doc:`decomposition <Decomposition>`.
Notice that typically a single  |EMr| contains several signal regions (|Datasets|) and there will be a set of efficiencies
(or efficiency maps) for each |dataset|. As a result, several theory predictions (one for each |dataset|) will be computed.
This procedure is similar (in nature) to 
the :ref:`Element Selection<ULselection>` applied in the case of an |ULr|, except that now it must be repeated for several |datasets|.


After the |element|'s weights have being rescaled by the corresponding efficiencies for the given |dataset| (signal region),
all of them can be grouped together in a single cluster, which will provide a single theory prediction (signal
cross-section) for the |Dataset|. Hence the :ref:`element clustering <EMcluster>` discussed below is completely trivial.
On the other hand the :ref:`element selection <EMselection>` is slightly more involved than in the |ULr|
case and will be discussed in more detail.

.. _EMselection:

Element Selection
^^^^^^^^^^^^^^^^^

The element selection for the case of a |EMr| consists of rescaling all the |elements|
weights by their efficiencies, according to the efficiency map of the corresponding |Dataset|.
The efficiency for a given |Dataset| depends both on the |element| mass and on its topology and particle content. 
In practice the efficiencies for most of the |elements| will be extremely small (or zero), hence only a subset effectively
contributes after the element selection  [*]_.

In the figure below we illustrate the element selection for the case of  a |EMr|/|Dataset|:

.. _EMselectionfig:

.. image:: images/EMselection.png
   :height: 500px 

If, for instance, the analysis being considered vetoes :math:`jets` and :math:`\tau`'s in the final state, 
we will have :math:`eff_2,eff_4 \simeq 0` for the example in the :ref:`figure above <EMselectionfig>`.
Nonetheless, the element selection for a  |Dataset| is usually more inclusive than
the one applied for the |ULr|, resulting in larger values for the theory prediction.


* **The element selection is implemented by the** `getElementsFrom <../../../documentation/build/html/theory.html#theory.theoryPrediction._getElementsFrom>`_ **method**

.. _EMcluster:

Element Clustering
^^^^^^^^^^^^^^^^^^

Unlike the clustering required in the case of |ULr| 
(see :ref:`Element Clustering for an UL analysis <ULcluster>`), after the efficiencies have been
applied to the element's weights, there is no longer the necessity to group the |elements|
according to their masses, since the mass differences have already been accounted for by the different efficiencies.
As a result, after the :ref:`element selection <EMselection>` all elements belong to a single cluster.


* **The (trivial) clustering of elements is implemented by the** `clusterElements <../../../documentation/build/html/theory.html#theory.clusterTools.clusterElements>`_  **method**.


Confronting Predictions with Experimental Limits
------------------------------------------------

Once the |elements| generated by the model :doc:`decomposition <Decomposition>`
have passed the *Element Selection* and *Clustering* processes, the theory predictions for a specific analysis
are given by the sum of all the |element|'s weights belonging to the same cluster (see :eq:`thpred`).

In the case of a |ULr|, where there can be more than one cluster (corresponding to distinct masses), there is a list of
theory predictions (one for each cluster) for a given result. Each theory prediction must then be compared to their
corresponding upper limits.
In the case of |ULr|, the limit is simply the cross-section upper limit provided by
the experimental publication or conference note (see |ULrs|) and is extracted from the corresponding UL map (see |ULrs|).

For |EMrs| there is a single cluster for each |Dataset|. However, since

The procedure described above can be applied to all the analyses in the database, resulting
in a list of theory predictions and upper limits for each analysis. A model can then be considered
excluded by the experimental results if, for one or more analysis, we have *theory prediction* :math:`>` *upper limit* [*]_.

* **The upper limits for a given**  |ULr| **can be obtained by the** `getUpperLimitFor <../../../documentation/build/html/theory.html#theory.analysis.ULanalysis.getUpperLimitFor>`_  **method**.




.. [*] When refering to an |element| mass, we mean all the :ref:`intermediate state <odd states>` masses
   appearing in the |element| (or the |element| mass array). Two |elements| are considered to have identical
   masses if their mass arrays are identical (see |element| and :ref:`Bracket Notation <bracketnotation>`
   for more details). 
.. [*] The number of |elements| passing the selection also depends on the availability of efficiency maps
   for the |elements| generated by the decomposition. Whenever there are no efficiencies available for a
   element, the efficiency is taken to be zero.
.. [*] The statistical significance of the exclusion statement is difficult to quantify exactly, since the model
   is being tested by a large number of analyses simultaneoustly.
