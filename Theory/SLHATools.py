#!/usr/bin/env python

"""
.. module:: SLHATools
    :synopsis: A collection of tools needed for use and manipulation of SLHA files
    
.. moduleauthor:: Doris Proschofsky <Doris.Proschofsky@assoc.oeaw.ac.at>
    
"""

import pyslha
import tempfile
import os

def createSLHAFile(topo, masses = None, filename = None, branching = None, totalwidth = None):
   """ Creates an SLHA File for a certain Tx name and certain masses.

     :param topo: Tx name
     :type topo: str
     :param masses: a dictionary {pid: mass} where pid is an integer and mass is \
       an integer or float, all masses not included in the dictionary are set to 100000\
       (by default masses from initial SLHA file are taken). 
     :param filename: by default a unique random filename will be generated.
     :type filenmame: str
     :param branching: a dictionary from a dictionary {pidmom: {"piddaugther1,piddaugther2,...": branching ratio, ...}...}\
       pidmom is an integer, pids of daugther particles are given as a string seperated by ',',\
       the branching ratio is a float or integer.
     :param totalwidth: a dictionary {pid: total width} where pid is an integer and total width is \
       an integer or float (by default total width from initial SLHA file is taken).
     :returns: the filename in string format
     """

   slha = pyslha.readSLHAFile('../slha/%s.slha' %topo)

   if masses:
      for pid in masses:
         slha[0]['MASS'].entries[pid] = masses[pid]

      for pid in slha[0]['MASS'].entries:
         if not masses.has_key(pid):
            slha[0]['MASS'].entries[pid] = 1.00000000e+05

   if branching:
      for pid in slha[1]:
         for k in range(len(slha[1][pid].decays)):
#            print 'deleting', slha[1][pid].decays[k]
            del slha[1][pid].decays[k]
      for pid in branching:
         if not slha[1].has_key(pid):
            slha[1][pid] = pyslha.Particle(pid)
            print "[SLHATools.py] Created new decay object for pid %d" %pid
#         print 'number of decays:', len(slha[1][pid].decays)
         for decay in branching[pid]:
            ids = decay.split(',')
            for i in ids:
               i.replace(' ','')
            slha[1][pid].add_decay(branching[pid][decay], len(ids), ids)

   if totalwidth:
      for pid in totalwidth:
         if not slha[1].has_key(pid):
            slha[1][pid] = pyslha.Particle(pid)
         slha[1][pid].totalwidth = totalwidth[pid]

   if filename:
      pyslha.writeSLHAFile(filename, slha[0], slha[1])
      return filename
   else:
      filename = tempfile.mkstemp()
      pyslha.writeSLHAFile(filename[1], slha[0], slha[1])
      return filename[1]

def writeXSECTIONToSLHAFile( slhafile, nevts=10000 ):
  """ calculates the production cross sections and writes it as XSECTION block in the SLHA file 

      :param slhafile: path of SLHA file
      :type slhafile: str
      :param nevts: number of events generated by pythia, default 10000
      :type nevts: int 
  """
  import tempfile
  import Theory.XSecComputer as XSEC
  import Tools.PhysicsUnits as UNIT

  fstate = "  " #final state, if necessary can be read out from DECAY block
  fstate = "# Nevts="+str(nevts) #additional information?

  Tmp = tempfile.mkdtemp()

  fin = open(slhafile, 'r')
  chck = fin.read()
  fin.close()
  if 'XSECTION' in chck: return False

  #computes production cross sections
  dic = XSEC.compute(nevts, slhafile, datadir = Tmp)

  #get CM dictionary
  CMdic = dic.CMdic()

  #write production cross sections to XSECTION block in SLHA file.
  writtenpids = []   #list of pids (keys) already written to the SLHA file, to avoid doubles
  f = open(slhafile, 'a')
  XsecDic = dic.crossSections()
  allpids = XsecDic[XsecDic.keys()[0]].keys()
  for pids in allpids:
    pid_xsecs = {}
#Collect all cross-sections for the pid pair
    for k in XsecDic:
      sqrtS = UNIT.rmvunit(CMdic[k],'TeV')
      if "(LO)" in k:
        cs_order = 0
      elif "(NLO)" in k:
        cs_order = 1
      elif "(NLL)" in k:
        cs_order = 2
      cs = dic.crossSections()[k][pids]
      cs = UNIT.rmvunit(cs,'fb')
      if not sqrtS in pid_xsecs.keys(): pid_xsecs[sqrtS] = []
      pid_xsecs[sqrtS].append([cs_order,cs])
#Write cross-sections grouped by sqrtS:
    for sqrtS in pid_xsecs.keys():
      f.write("\nXSECTION  %f  %d  %d  %d  %d  %d  %s\n" %(sqrtS, 2212, 2212, 2, pids[0], pids[1], fstate))
      for line_cs in pid_xsecs[sqrtS]:
        f.write("0  %d  0  0  0  0  %f XSecComputer 1.0\n" %(line_cs[0],line_cs[1]))


  f.close

  XSEC.clean(Tmp)
  return
