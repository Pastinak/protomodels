#!/usr/bin/env python

"""
.. module:: SLHATools
    :synopsis: A collection of tools needed for use and manipulation of SLHA files
    
.. moduleauthor:: Doris Proschofsky <Doris.Proschofsky@assoc.oeaw.ac.at>
    
"""

import pyslha
import tempfile
import os

def createSLHAFile(topo, masses = None, filename = None, branching = None, totalwidth = None):
   """ Creates an SLHA File for a certain Tx name and certain masses.

     :param topo: Tx name
     :type topo: str
     :param masses: a dictionary {pid: mass} where pid is an integer and mass is \
       an integer or float, all masses not included in the dictionary are set to 100000\
       (by default masses from initial SLHA file are taken). 
     :param filename: by default a unique random filename will be generated.
     :type filenmame: str
     :param branching: a dictionary from a dictionary {pidmom: {"piddaugther1,piddaugther2,...": branching ratio, ...}...}\
       pidmom is an integer, pids of daugther particles are given as a string seperated by ',',\
       the branching ratio is a float or integer.
     :param totalwidth: a dictionary {pid: total width} where pid is an integer and total width is \
       an integer or float (by default total width from initial SLHA file is taken).
     :returns: the filename in string format
     """

   slha = pyslha.readSLHAFile('../slha/%s.slha' %topo)

   if masses:
      for pid in masses:
         slha[0]['MASS'].entries[pid] = masses[pid]

      for pid in slha[0]['MASS'].entries:
         if not masses.has_key(pid):
            slha[0]['MASS'].entries[pid] = 1.00000000e+05

   if branching:
      for pid in slha[1]:
         for k in range(len(slha[1][pid].decays)):
#            print 'deleting', slha[1][pid].decays[k]
            del slha[1][pid].decays[k]
      for pid in branching:
         if not slha[1].has_key(pid):
            slha[1][pid] = pyslha.Particle(pid)
            print "[SLHATools.py] Created new decay object for pid %d" %pid
#         print 'number of decays:', len(slha[1][pid].decays)
         for decay in branching[pid]:
            ids = decay.split(',')
            for i in ids:
               i.replace(' ','')
            slha[1][pid].add_decay(branching[pid][decay], len(ids), ids)

   if totalwidth:
      for pid in totalwidth:
         if not slha[1].has_key(pid):
            slha[1][pid] = pyslha.Particle(pid)
         slha[1][pid].totalwidth = totalwidth[pid]

   if filename:
      pyslha.writeSLHAFile(filename, slha[0], slha[1])
      return filename
   else:
      filename = tempfile.mkstemp()
      pyslha.writeSLHAFile(filename[1], slha[0], slha[1])
      return filename[1]

def writeXSECTIONToSLHAFile( slhafile, nevts=10000 ):
  """ calculates the production cross sections and writes it as XSECTION block in the SLHA file 

      :param slhafile: path of SLHA file
      :type slhafile: str
      :param nevts: number of events generated by pythia, default 10000
      :type nevts: int 
  """
  import tempfile
  import Theory.XSecComputer as XSEC
  import Tools.PhysicsUnits as UNIT

  fstate = "  " #final state, if necessary can be read out from DECAY block

  Tmp = tempfile.mkdtemp()

  #computes production cross sections
  dic = XSEC.compute(nevts, slhafile, datadir = Tmp)   

  #write production cross sections to XSECTION block in SLHA file.
  writtenpids = []   #list of pids (keys) already written to the SLHA file, to avoid doubles
  f = open(slhafile, 'a')
  for k in dic.crossSections():
    for pids in dic.crossSections()[k]:
      if pids in writtenpids:    #to avoid doubles
        continue
      else:
        writtenpids.append(pids)      
        for sqrt in [7,8]:
          csLO = UNIT.rmvunit(dic.getCrossSection(pids[0], pids[1], order="LO" , sqrts = sqrt),'fb')
          csNLL = UNIT.rmvunit(dic.getCrossSection(pids[0], pids[1], order="NLL" , sqrts = sqrt),'fb')
          if csLO or csNLL:
            f.write("\n")
            f.write("XSECTION  %d  %d  %d  %s\n" %(sqrt, pids[0], pids[1], fstate))
          if csLO:
            f.write("0  0  0  0  0  0  %f XSecComputer 1.0\n" %csLO)
          if csNLL:
           f.write("0  2  0  0  0  0  %f XSecComputer 1.0\n" %csNLL)

  f.close

  XSEC.clean(Tmp)
  return
